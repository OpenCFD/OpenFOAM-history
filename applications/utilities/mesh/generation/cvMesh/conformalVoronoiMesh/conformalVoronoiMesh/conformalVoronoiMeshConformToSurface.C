/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2012 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "conformalVoronoiMesh.H"
#include "backgroundMeshDecomposition.H"
#include "vectorTools.H"

using namespace Foam::vectorTools;

const Foam::scalar Foam::conformalVoronoiMesh::searchConeAngle
    = Foam::cos(degToRad(30));

const Foam::scalar Foam::conformalVoronoiMesh::searchAngleOppositeSurface
    = Foam::cos(degToRad(150));

// * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * * //

void Foam::conformalVoronoiMesh::conformToSurface()
{
    reconformationMode reconfMode = reconformationControl();

//    if (Pstream::parRun())
//    {
//        seedProcessorBoundarySurfaces(true);
//    }

    if (reconfMode == rmNone)
    {
        // Reinsert stored surface conformation
        reinsertSurfaceConformation();

        buildParallelInterface("move_" + runTime_.timeName());
    }
    else
    {
        // Rebuild, insert and store new surface conformation
        buildSurfaceConformation(reconfMode);

        if (distributeBackground())
        {
            // distributeBackground has destroyed all referred vertices, so the
            // parallel interface needs to be rebuilt.
            buildParallelInterface("rebuild");

            // Use storeSizesAndAlignments with no feed points because all
            // background points may have been distributed.
            storeSizesAndAlignments();
        }

        // Do not store the surface conformation until after it has been
        // (potentially) redistributed.
        storeSurfaceConformation();
    }

//    if (Pstream::parRun())
//    {
//        label nFarPoints = removeProcessorBoundarySeeds(true);
//
//        reduce(nFarPoints, sumOp<label>());
//
//        Info<< "    Removed " << nFarPoints
//            << " far points from the mesh." << endl;
//    }

    // reportSurfaceConformationQuality();
}


Foam::conformalVoronoiMesh::reconformationMode
Foam::conformalVoronoiMesh::reconformationControl() const
{
    if (!runTime_.run())
    {
        Info<< nl << "Rebuilding surface conformation for final output"
            << endl;

        return rmFine;
    }
    else if
    (
        runTime_.timeIndex()
      % cvMeshControls().surfaceConformationRebuildFrequency() == 0
    )
    {
        Info<< nl << "Rebuilding surface conformation for more iterations"
            << endl;

        return rmCoarse;
    }

    return rmNone;
}


void Foam::conformalVoronoiMesh::buildSurfaceConformation
(
    reconformationMode reconfMode
)
{
    timeCheck("Start buildSurfaceConformation");

    if (reconfMode == rmCoarse)
    {
        Info<< nl << "Build coarse surface conformation" << endl;
    }
    else if (reconfMode == rmFine)
    {
        Info<< nl << "Build fine surface conformation" << endl;
    }
    else if (reconfMode == rmNone)
    {
        WarningIn("buildSurfaceConformation(reconformationMode reconfMode)")
            << "reconformationMode rmNone specified, not building conformation"
            << endl;

        return;
    }
    else
    {
        WarningIn("buildSurfaceConformation(reconformationMode reconfMode)")
            << "Unknown reconformationMode " << reconfMode
            << " not building conformation" << endl;

        return;
    }

    // Initialise containers to store the edge conformation locations
    DynamicList<Foam::point> newEdgeLocations;

    DynamicList<Foam::point> existingEdgeLocations;
    DynamicList<Foam::point> existingSurfacePtLocations;

    buildEdgeLocationTree(existingEdgeLocations);
    buildSurfacePtLocationTree(existingSurfacePtLocations);

    label initialTotalHits = 0;

    // Surface protrusion conformation is done in two steps.
    // 1. the dual edges (of all internal vertices) can stretch to
    //    'infinity' so any intersection would be badly behaved. So
    //    just find the nearest point on the geometry and insert point
    //    pairs.
    // Now most of the surface conformation will be done with some
    // residual protrusions / incursions.
    // 2. find any segments of dual edges outside the geometry. Shoot
    //    ray from Delaunay vertex to middle of this segment and introduce
    //    point pairs. This will handle e.g.

    // protruding section of face:
    //
    //     internal
    // \             /
    // -+-----------+-- boundary
    //   \         /
    //     --------
    //
    // Shoot ray and find intersection with outside segment (x) and
    // introduce pointpair (..)
    //
    //        |
    // \      .      /
    // -+-----|-----+-- boundary
    //   \    .    /
    //     ---x----

    label countNearBoundaryVertices = 0;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->internalPoint() && !vit->nearBoundary())
        {
            pointFromPoint pt = topoint(vit->point());
            const scalar range = sqr(2.0*targetCellSize(pt));

            pointIndexHit pHit;
            label hitSurface;

            geometryToConformTo_.findSurfaceNearest
            (
                pt,
                range,
                pHit,
                hitSurface
            );

            if (pHit.hit())
            {
                vit->setNearBoundary();
                countNearBoundaryVertices++;
            }
        }
    }

    Info<< "    Vertices marked as being near a boundary: "
        << countNearBoundaryVertices << " (estimated)" << endl;

    timeCheck("After set near boundary");

    // Initial surface protrusion conformation - nearest surface point
    {
        const scalar edgeSearchDistCoeffSqr =
            cvMeshControls().edgeSearchDistCoeffSqrInitial(reconfMode);

        const scalar surfacePtReplaceDistCoeffSqr =
            cvMeshControls().surfacePtReplaceDistCoeffSqrInitial(reconfMode);

        DynamicList<pointIndexHit> surfaceHits;
        DynamicList<label> hitSurfaces;

        DynamicList<pointIndexHit> featureEdgeHits;
        DynamicList<label> featureEdgeFeaturesHit;

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            if (vit->internalPoint() && vit->nearBoundary())
            {
                const Foam::point vert = topoint(vit->point());

                if (!positionOnThisProc(vert))
                {
                    continue;
                }

                DynamicList<pointIndexHit> surfHitList;
                DynamicList<label> hitSurfaceList;

                if
                (
                    dualCellSurfaceAllIntersections
                    (
                        vit,
                        surfHitList,
                        hitSurfaceList
                    )
                )
                {
                    // meshTools::writeOBJ(Pout, vert);
                    // meshTools::writeOBJ(Pout, surfHit.hitPoint());
                    // Pout<< "l cr0 cr1" << endl;

                    addSurfaceAndEdgeHits
                    (
                        vit,
                        vert,
                        surfHitList,
                        hitSurfaceList,
                        surfacePtReplaceDistCoeffSqr,
                        edgeSearchDistCoeffSqr,
                        surfaceHits,
                        hitSurfaces,
                        featureEdgeHits,
                        featureEdgeFeaturesHit,
                        newEdgeLocations,
                        existingEdgeLocations,
                        existingSurfacePtLocations
                    );
                }
                else
                {
                    vit->setInternal();
                    countNearBoundaryVertices--;
                }
            }
        }

        Info<< "    Vertices marked as being near a boundary: "
            << countNearBoundaryVertices
            << " (after dual surface intersection)" << endl;

        label nVerts = number_of_vertices();
        label nSurfHits = surfaceHits.size();
        label nFeatEdHits = featureEdgeHits.size();

        if (Pstream::parRun())
        {
            reduce(nVerts, sumOp<label>());
            reduce(nSurfHits, sumOp<label>());
            reduce(nFeatEdHits, sumOp<label>());
        }

        Info<< nl << "Initial conformation" << nl
            << "    Number of vertices " << nVerts << nl
            << "    Number of surface hits " << nSurfHits << nl
            << "    Number of edge hits " << nFeatEdHits
            << endl;

        insertSurfacePointPairs
        (
            surfaceHits,
            hitSurfaces,
            "surfaceConformationLocations_initial.obj"
        );

        insertEdgePointGroups
        (
            featureEdgeHits,
            featureEdgeFeaturesHit,
            "edgeConformationLocations_initial.obj"
        );

        timeCheck("After initial conformation");

        initialTotalHits = nSurfHits + nFeatEdHits;
    }

    // Remember which vertices were referred to each processor so only updates
    // are sent.
    List<labelHashSet> referralVertices(Pstream::nProcs());

    // Store the vertices that have been received and added from each processor
    // already so that there is no attempt to add them more than once.
    List<labelHashSet> receivedVertices(Pstream::nProcs());

    // Build the parallel interface the initial surface conformation
    buildParallelInterface(referralVertices, receivedVertices, true, "initial");

    label iterationNo = 0;

    label maxIterations =
        cvMeshControls().maxConformationIterations(reconfMode);

    scalar iterationToInitialHitRatioLimit =
        cvMeshControls().iterationToInitialHitRatioLimit(reconfMode);

    label hitLimit = label(iterationToInitialHitRatioLimit*initialTotalHits);

    Info<< nl << "Stopping iterations when: " << nl
        <<"    total number of hits drops below "
        << iterationToInitialHitRatioLimit << " of initial hits ("
        << hitLimit << ")" << nl
        << " or " << nl
        << "    maximum number of iterations ("
        << maxIterations << ") is reached"
        << endl;

    // Set totalHits to a large enough positive value to enter the while loop on
    // the first iteration
    label totalHits = initialTotalHits;

    while
    (
        totalHits > 0
     && totalHits >= hitLimit
     && iterationNo < maxIterations
    )
    {
        scalar edgeSearchDistCoeffSqr =
            cvMeshControls().edgeSearchDistCoeffSqrIteration(reconfMode);

        scalar surfacePtReplaceDistCoeffSqr =
            cvMeshControls().surfacePtReplaceDistCoeffSqrIteration(reconfMode);

        DynamicList<pointIndexHit> surfaceHits;
        DynamicList<label> hitSurfaces;

        DynamicList<pointIndexHit> featureEdgeHits;
        DynamicList<label> featureEdgeFeaturesHit;

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            ++vit
        )
        {
            // The initial surface conformation has already identified the
            // nearBoundary set of vertices.  Previously inserted boundary
            // points and referred internal vertices from other processors can
            // also generate protrusions and must be assessed too.
            if
            (
                vit->nearBoundary()
             || vit->ppMaster()
             || vit->referredInternalOrBoundaryPoint()
            )
            {
                const Foam::point vert = topoint(vit->point());

                pointIndexHit surfHit;
                label hitSurface;

                // Find segments of dual face outside the geometry and find the
                // the middle of this
                dualCellLargestSurfaceProtrusion(vit, surfHit, hitSurface);

                if (surfHit.hit())
                {
                    DynamicList<pointIndexHit> tmpPIH;
                    tmpPIH.append(surfHit);

                    DynamicList<label> tmpHS;
                    tmpHS.append(hitSurface);

                    addSurfaceAndEdgeHits
                    (
                        vit,
                        vert,
                        tmpPIH,
                        tmpHS,
                        surfacePtReplaceDistCoeffSqr,
                        edgeSearchDistCoeffSqr,
                        surfaceHits,
                        hitSurfaces,
                        featureEdgeHits,
                        featureEdgeFeaturesHit,
                        newEdgeLocations,
                        existingEdgeLocations,
                        existingSurfacePtLocations
                    );
                }
//                else
//                {
//                    vit->setInternal();
//                }
            }
            else if (vit->ppSlave() || vit->referredExternal())
            {
                const Foam::point vert = topoint(vit->point());

                pointIndexHit surfHit;
                label hitSurface;

                // Detect slave (external vertices) whose dual face incurs
                // into nearby (other than originating) geometry
                dualCellLargestSurfaceIncursion(vit, surfHit, hitSurface);

                if (surfHit.hit())
                {
                    DynamicList<pointIndexHit> tmpPIH;
                    tmpPIH.append(surfHit);

                    DynamicList<label> tmpHS;
                    tmpHS.append(hitSurface);

                    addSurfaceAndEdgeHits
                    (
                        vit,
                        vert,
                        tmpPIH,
                        tmpHS,
                        surfacePtReplaceDistCoeffSqr,
                        edgeSearchDistCoeffSqr,
                        surfaceHits,
                        hitSurfaces,
                        featureEdgeHits,
                        featureEdgeFeaturesHit,
                        newEdgeLocations,
                        existingEdgeLocations,
                        existingSurfacePtLocations
                    );
                }
//                else
//                {
//                    vit->setInternal();
//                }
            }
        }

        label nVerts = number_of_vertices();
        label nSurfHits = surfaceHits.size();
        label nFeatEdHits = featureEdgeHits.size();

        if (Pstream::parRun())
        {
            reduce(nVerts, sumOp<label>());
            reduce(nSurfHits, sumOp<label>());
            reduce(nFeatEdHits, sumOp<label>());
        }

        Info<< nl << "Conformation iteration " << iterationNo << nl
            << "    Number of vertices " << nVerts << nl
            << "    Number of surface hits " << nSurfHits << nl
            << "    Number of edge hits " << nFeatEdHits
            << endl;

        totalHits = nSurfHits + nFeatEdHits;

        if (totalHits > 0)
        {
            insertSurfacePointPairs
            (
                surfaceHits,
                hitSurfaces,
                fileName
                (
                    "surfaceConformationLocations_" + name(iterationNo) + ".obj"
                )
            );

            insertEdgePointGroups
            (
                featureEdgeHits,
                featureEdgeFeaturesHit,
                "edgeConformationLocations_" + name(iterationNo) + ".obj"
            );
        }

        timeCheck("Conformation iteration " + name(iterationNo));

        // Only need to update the interface if there are surface/edge hits
        if (totalHits > 0)
        {
            // Update the parallel interface
            buildParallelInterface
            (
                referralVertices,
                receivedVertices,
                false,
                name(iterationNo)
            );
        }

        iterationNo++;

        if (iterationNo == maxIterations)
        {
            WarningIn("conformalVoronoiMesh::conformToSurface()")
                << "Maximum surface conformation iterations ("
                << maxIterations <<  ") reached." << endl;
        }

        if (totalHits < hitLimit)
        {
            Info<< nl << "Total hits (" << totalHits
                << ") less than limit (" << hitLimit
                << "), stopping iterations" << endl;
        }
    }
}


bool Foam::conformalVoronoiMesh::dualCellSurfaceAnyIntersection
(
    const Delaunay::Finite_vertices_iterator& vit
) const
{
    std::list<Facet> facets;
    incident_facets(vit, std::back_inserter(facets));

    for
    (
        std::list<Facet>::iterator fit=facets.begin();
        fit != facets.end();
        ++fit
    )
    {
        if
        (
            is_infinite(fit->first)
         || is_infinite(fit->first->neighbor(fit->second))
        )
        {
            continue;
        }

        Foam::point dE0 = fit->first->dual();
        Foam::point dE1 = fit->first->neighbor(fit->second)->dual();

        if (Pstream::parRun())
        {
            Foam::point& a = dE0;
            Foam::point& b = dE1;

            bool inProc = clipLineToProc(topoint(vit->point()), a, b);

            // Check for the edge passing through a surface
            if
            (
                inProc
             && geometryToConformTo_.findSurfaceAnyIntersection(a, b)
            )
            {
                // Pout<< "# findSurfaceAnyIntersection" << endl;
                // meshTools::writeOBJ(Pout, a);
                // meshTools::writeOBJ(Pout, b);
                // Pout<< "l cr0 cr1" << endl;

                return true;
            }
        }
        else
        {
            if (geometryToConformTo_.findSurfaceAnyIntersection(dE0, dE1))
            {
                return true;
            }
        }
    }

    return false;
}


bool Foam::conformalVoronoiMesh::dualCellSurfaceAllIntersections
(
    const Delaunay::Finite_vertices_iterator& vit,
    DynamicList<pointIndexHit>& infoList,
    DynamicList<label>& hitSurfaceList
) const
{
    bool flagIntersection = false;

    std::list<Facet> facets;
    incident_facets(vit, std::back_inserter(facets));

    for
    (
        std::list<Facet>::iterator fit = facets.begin();
        fit != facets.end();
        ++fit
    )
    {
        if
        (
            is_infinite(fit->first)
         || is_infinite(fit->first->neighbor(fit->second))
        )
        {
            continue;
        }

        // Construct the dual edge and search for intersections of the edge
        // with the surface
        Foam::point dE0 = fit->first->dual();
        Foam::point dE1 = fit->first->neighbor(fit->second)->dual();

        pointIndexHit infoIntersection;
        label hitSurfaceIntersection = -1;

        if (Pstream::parRun())
        {
            bool inProc = clipLineToProc(topoint(vit->point()), dE0, dE1);

            if (!inProc)
            {
                continue;
            }
        }

        geometryToConformTo_.findSurfaceNearestIntersection
        (
            dE0,
            dE1,
            infoIntersection,
            hitSurfaceIntersection
        );

        if (infoIntersection.hit())
        {
            vectorField norm(1);

            allGeometry_[hitSurfaceIntersection].getNormal
            (
                List<pointIndexHit>(1, infoIntersection),
                norm
            );

            const vector& n = norm[0];

            const Foam::point vertex = topoint(vit->point());

            const plane p(infoIntersection.hitPoint(), n);

            const plane::ray r(vertex, n);

            const scalar d = p.normalIntersect(r);

            const Foam::point newPoint = vertex + d*n;

            pointIndexHit info;
            label hitSurface = -1;

            geometryToConformTo_.findSurfaceNearest
            (
                newPoint,
                surfaceSearchDistanceSqr(newPoint),
                info,
                hitSurface
            );

            bool rejectPoint = false;

            if (info.hit())
            {
                if (!infoList.empty())
                {
                    forAll(infoList, hitI)
                    {
                        // Reject point if the point is already added
                        if (infoList[hitI].index() == info.index())
                        {
                            rejectPoint = true;
                            break;
                        }

                        const Foam::point& p = infoList[hitI].hitPoint();

                        const scalar separationDistance =
                            mag(p - info.hitPoint());

                        const scalar minSepDist =
                            sqr
                            (
                                cvMeshControls().removalDistCoeff()
                               *targetCellSize(p)
                            );

                        // Reject the point if it is too close to another
                        // surface point.
                        // Could merge the points?
                        if (separationDistance < minSepDist)
                        {
                            rejectPoint = true;
                            break;
                        }
                    }
                }
            }

            // The normal ray from the vertex will not always result in a hit
            // because another surface may be in the way.
            if (!rejectPoint && info.hit())
            {
                flagIntersection = true;
                infoList.append(info);
                hitSurfaceList.append(hitSurface);
            }
        }
    }

    return flagIntersection;
}


bool Foam::conformalVoronoiMesh::clipLineToProc
(
    const Foam::point& pt,
    Foam::point& a,
    Foam::point& b
) const
{
    bool inProc = false;

    pointIndexHit findAnyIntersection = decomposition_().findLine(a, b);

    if (!findAnyIntersection.hit())
    {
        pointIndexHit info = decomposition_().findLine(a, pt);

        if (!info.hit())
        {
            inProc = true;
        }
        else
        {
            inProc = false;
        }
    }
    else
    {
        pointIndexHit info = decomposition_().findLine(a, pt);

        if (!info.hit())
        {
            inProc = true;
            b = findAnyIntersection.hitPoint();
        }
        else
        {
            inProc = true;
            a = findAnyIntersection.hitPoint();
        }
    }

    return inProc;
}


void Foam::conformalVoronoiMesh::buildParallelInterface
(
    const word& outputName
)
{
    List<labelHashSet> referralVertices(Pstream::nProcs());
    List<labelHashSet> receivedVertices(Pstream::nProcs());

    buildParallelInterface
    (
        referralVertices,
        receivedVertices,
        true,
        outputName
    );
}


Foam::label Foam::conformalVoronoiMesh::removeProcessorBoundarySeeds
(
    bool reinsertBoundPts
)
{
    label nFarPoints = 0;



    std::list<Vertex_handle> toRemove;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->farPoint())
        {
            //remove(vit);
            toRemove.push_back(vit);
            nFarPoints++;
        }
    }

    // This function removes the points in the iterator range and then
    // retriangulates.
    timeCheck("Start Removing Seeded Points " + name(toRemove.size()));

    remove_cluster(toRemove.begin(), toRemove.end());


    // Need to do this to make sure the triangulation is well-behaved
    if (reinsertBoundPts)
    {
        reinsertBoundingPoints();
    }



//    DynamicList<Foam::point> toAdd;
//    DynamicList<label> indices;
//    DynamicList<label> types;
//
//    for
//    (
//        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
//        vit != finite_vertices_end();
//        ++vit
//    )
//    {
//        if (!vit->farPoint())
//        {
//            toAdd.append(topoint(vit->point()));
//            indices.append(vit->index());
//            types.append(vit->type());
//
//            nFarPoints++;
//        }
//    }
//
//    this->clear();
//
//    // Need to do this to make sure the triangulation is well-behaved
//    if (reinsertBoundPts)
//    {
//        reinsertBoundingPoints();
//    }
//
//    forAll(toAdd, pI)
//    {
//        insertPoint(toAdd[pI], indices[pI], types[pI]);
//    }


    timeCheck("End Removing Seeded Points");

    return nFarPoints;
}


void Foam::conformalVoronoiMesh::seedProcessorBoundarySurfaces
(
    bool seedProcessors
)
{
    //removeProcessorBoundarySeeds(false);

    // Loop over processor patch faces and insert a point in the centre of the
    // face
    const fvMesh& mesh = decomposition_().mesh();
    const polyBoundaryMesh& bMesh = mesh.boundaryMesh();

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    label nFarPoints = 0;

    const scalar normalDistance = 2.0;
    const scalar pert = 0.1*(rndGen_.scalar01() - 0.5);

    forAll(bMesh, patchI)
    {
        const polyPatch& patch = bMesh[patchI];

        if (!seedProcessors && isA<processorPolyPatch>(patch))
        {
            continue;
        }

        forAll(patch, faceI)
        {
            if (faceI % 1 == 0)
            {
                const face& f = patch[faceI];

                pts.append
                (
                    f.centre(mesh.points())
                  + pert*normalDistance*f.normal(mesh.points())
                );
                indices.append(nFarPoints++);
                types.append(Vb::vtFar);
            }
        }
    }

    insertPoints(pts, indices, types, false);

    reduce(nFarPoints, sumOp<label>());

    Info<< "    Inserted " << nFarPoints
        << " far points into the mesh." << endl;
}


void Foam::conformalVoronoiMesh::buildParallelInterface
(
    List<labelHashSet>& referralVertices,
    List<labelHashSet>& receivedVertices,
    bool initialEdgeReferral,
    const word& outputName
)
{
    if (!Pstream::parRun())
    {
        return;
    }

    Info<< nl << "Parallel interface construction" << endl;

    timeCheck("Before buildParallelInterface");

    // Hard coded switch, can be turned on for testing and debugging purposes -
    // all vertices will be referred to all processors, use with caution for
    // big cases.
    bool allPointReferral = false;

    if (allPointReferral)
    {
        buildParallelInterfaceAll
        (
            referralVertices,
            receivedVertices,
            outputName
        );

        timeCheck("After buildParallelInterfaceAll");
    }


    // Reject points that are not near the boundary from the subsequent
    // searches

//    label nearProcCount = 0;
//    label notNearProcCount = 0;
//    boundBox quickRejectionBox(decomposition_().procBounds());
//
////    Pout<< "Processor boundBox: " << quickRejectionBox << endl;
//
//    quickRejectionBox.inflate(-0.1);
//
//    OFstream str("rejectionBox_" + name(Pstream::myProcNo()) + ".obj");
//
//    meshTools::writeOBJ
//    (
//        str,
//        boundBox::faces(),
//        quickRejectionBox.points()
//    );
//
//    Pout<< "Inflated rejection boundBox: " << quickRejectionBox << endl;

//    for
//    (
//        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
//        vit != finite_vertices_end();
//        vit++
//    )
//    {
//        if (vit->real() && !vit->nearProcBoundary())
//        {
//            const Foam::point& pt = topoint(vit->point());
//            const scalar range = targetCellSize(pt);
//
////            if
////            (
////                decomposition_().overlapsThisProcessor
////                (
////                    pt,
////                    range
////                )
////            )
//            if (!quickRejectionBox.contains(pt))
//            {
//                vit->setNearProcBoundary();
//                nearProcCount++;
//            }
//            else
//            {
//                //vit->setNearProcBoundary();
//                notNearProcCount++;
//            }
//        }
//    }
//
//    reduce(nearProcCount, sumOp<label>());
//    reduce(notNearProcCount, sumOp<label>());
//
//    timeCheck
//    (
//        "End of potential intersection search. "
//      + name(nearProcCount) + " are near a processor boundary. "
//      + name(notNearProcCount) + " are not."
//    );

//    if (initialEdgeReferral)
//    {
//        // Used as an initial pass to localise the vertex referring - find
//        // vertices whose dual edges pierce nearby processor volumes and refer
//        // them to establish a sensible boundary interface region before
//        // running a circumsphere assessment.
//
//        buildParallelInterfaceIntersection
//        (
//            referralVertices,
//            receivedVertices,
//            outputName
//        );
//
//        timeCheck("After buildParallelInterfaceIntersection");
//    }

    buildParallelInterfaceInfluence
    (
        referralVertices,
        receivedVertices,
        outputName
    );

    timeCheck("After buildParallelInterface");

    // Check all referred vertices are actually used on the processor.
    label nUnusedReferred = numberOfUnusedReferredPoints();

    reduce(nUnusedReferred, sumOp<label>());

    Info<< "    Number of referred points that are not used : "
        << nUnusedReferred << " (approximate)" << endl;
}


Foam::label Foam::conformalVoronoiMesh::numberOfUnusedReferredPoints() const
{
    label nUnusedPoints = 0;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->referred())
        {
            std::list<Vertex_handle> adjVertices;
            finite_adjacent_vertices(vit, std::back_inserter(adjVertices));

            bool isUsed = false;

            for
            (
                std::list<Vertex_handle>::iterator adjVit = adjVertices.begin();
                adjVit != adjVertices.end();
                ++adjVit
            )
            {
                if ((*adjVit)->real())
                {
                    isUsed = true;
                }
            }

            if (!isUsed)
            {
                nUnusedPoints++;
            }
        }
    }

    return nUnusedPoints;
}


void Foam::conformalVoronoiMesh::buildParallelInterfaceAll
(
    List<labelHashSet>& referralVertices,
    List<labelHashSet>& receivedVertices,
    const word& outputName
)
{
    // Refer all points to all processors

    DynamicList<Foam::point> parallelAllPoints;
    DynamicList<label> targetProcessor;
    DynamicList<label> parallelAllIndices;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (!vit->farPoint())
        {
            for (label procI = 0; procI < Pstream::nProcs(); procI++)
            {
                if (procI == Pstream::myProcNo())
                {
                    continue;
                }

                label vIndex = vit->index();

                // Using the hashSet to ensure that each vertex is
                // only referred once to each processor
                if (!referralVertices[procI].found(vIndex))
                {
                    referralVertices[procI].insert(vIndex);

                    parallelAllPoints.append
                    (
                        topoint(vit->point())
                    );

                    targetProcessor.append(procI);

                    if (vit->internalOrBoundaryPoint())
                    {
                        parallelAllIndices.append(vIndex);
                    }
                    else
                    {
                        parallelAllIndices.append(-vIndex);
                    }
                }
            }
        }
    }

    referVertices
    (
        targetProcessor,
        parallelAllPoints,
        parallelAllIndices,
        receivedVertices,
        "all",
        outputName
    );
}

void Foam::conformalVoronoiMesh::buildParallelInterfaceIntersection
(
    List<labelHashSet>& referralVertices,
    List<labelHashSet>& receivedVertices,
    const word& outputName
)
{
    DynamicList<Foam::point> parallelIntersectionPoints;
    DynamicList<label> targetProcessor;
    DynamicList<label> parallelIntersectionIndices;

    // End points of dual edges.  Some of these values will not be used,
    // i.e. for edges with non-real vertices.
    DynamicList<Foam::point> dE0;
    DynamicList<Foam::point> dE1;

    PackedBoolList testFacetIntersection(number_of_facets(), false);

    // Index outer (all) Delaunauy facets for whether they are potential
    // intersections, index (inner) the list of tests an results.
    label fIInner = 0;
    label fIOuter = 0;

    for
    (
        Delaunay::Finite_facets_iterator fit = finite_facets_begin();
        fit != finite_facets_end();
        ++fit
    )
    {
        const Cell_handle c1(fit->first);
        const Cell_handle c2(c1->neighbor(fit->second));

        // If either Delaunay cell at the end of the Dual edge is infinite,
        // skip.
        if
        (
            !is_infinite(c1) && !is_infinite(c2)
        )
        {
            // The Delaunauy cells at either end of the dual edge need to be
            // real, i.e. all vertices form part of the internal or boundary
            // definition
            if
            (
                c1->internalOrBoundaryDualVertex()
             && c2->internalOrBoundaryDualVertex()
            )
            {
                const Foam::point& a = c1->dual();
                const Foam::point& b = c2->dual();

                // Only if the dual edge cuts the boundary of this processor is
                // it going to be counted.
                pointIndexHit info = decomposition_().findLineAny(a, b);

                if (info.hit())
                {
                    dE0.append(a);
                    dE1.append(b);

                    testFacetIntersection[fIOuter] = true;
                }
            }
        }

        fIOuter++;
    }

    reduce(fIOuter, sumOp<label>());

    timeCheck
    (
        "End of actual intersection search over "
      + name(fIOuter)
      + " faces."
    );

    // Preform intersections in both directions, as there is no sense
    // associated with the Dual edge
    List<List<pointIndexHit> > intersectionForward(intersectsProc(dE0, dE1));
    List<List<pointIndexHit> > intersectionReverse(intersectsProc(dE1, dE0));

    timeCheck("End of find processor intersection");

    // Reset counter
    fIOuter = 0;

    // Relying on the order of iteration of facets being the same as before
    for
    (
        Delaunay::Finite_facets_iterator fit = finite_facets_begin();
        fit != finite_facets_end();
        ++fit
    )
    {
        const Cell_handle c1(fit->first);
        const Cell_handle c2(c1->neighbor(fit->second));

        // Pre-tested facet intersection potential
        if (testFacetIntersection[fIOuter])
        {
            const Foam::point a = dE0[fIInner];
            const Foam::point b = dE1[fIInner];

            scalar hitDistSqr = GREAT;
            label closestHitProc = -1;
            scalar closestHitDistSqr = GREAT;

            // Find the closest intersection with the other background meshes
            // of the other processors in each direction, finding the closest.
            forAll(intersectionForward[fIInner], iFI)
            {
                const pointIndexHit& info = intersectionForward[fIInner][iFI];

                if (info.hit())
                {
                    // Line was a -> hit
                    hitDistSqr = magSqr(a - info.hitPoint());
                }

                if (hitDistSqr < closestHitDistSqr)
                {
                    closestHitProc = info.index();
                    closestHitDistSqr = hitDistSqr;
                }
            }

            forAll(intersectionReverse[fIInner], iRI)
            {
                const pointIndexHit& info = intersectionReverse[fIInner][iRI];

                if (info.hit())
                {
                    // Line was b -> hit
                    hitDistSqr = magSqr(b - info.hitPoint());
                }

                if (hitDistSqr < closestHitDistSqr)
                {
                    closestHitProc = info.index();
                    closestHitDistSqr = hitDistSqr;
                }
            }

            if (closestHitProc >= 0)
            {
                // This dual edge pierces a processor, refer all vertices from
                // both Delaunauy cells to it.

                for (int i = 0; i < 4; i++)
                {
                    Vertex_handle v = c1->vertex(i);

                    label vIndex = v->index();

                    if (v->farPoint() || v->referred())
                    {
                        continue;
                    }

                    // Using the hashSet to ensure that each vertex is only
                    // referred once to each processor
                    if (!referralVertices[closestHitProc].found(vIndex))
                    {
                        referralVertices[closestHitProc].insert(vIndex);

                        parallelIntersectionPoints.append(topoint(v->point()));

                        targetProcessor.append(closestHitProc);

                        if (v->internalOrBoundaryPoint())
                        {
                            parallelIntersectionIndices.append(vIndex);
                        }
                        else
                        {
                            parallelIntersectionIndices.append(-vIndex);
                        }

                        // Pout<< "Refer "
                        //     << parallelIntersectionPoints.last()
                        //     << " " << parallelIntersectionIndices.last()
                        //     << " " << closestHitProc
                        //     << endl;
                    }
                }

                for (int i = 0; i < 4; i++)
                {
                    Vertex_handle v = c2->vertex(i);

                    label vIndex = v->index();

                    if (v->farPoint() || v->referred())
                    {
                        continue;
                    }

                    // Using the hashSet to ensure that each vertex is only
                    // referred once to each processor
                    if (!referralVertices[closestHitProc].found(vIndex))
                    {
                        referralVertices[closestHitProc].insert(vIndex);

                        parallelIntersectionPoints.append(topoint(v->point()));

                        targetProcessor.append(closestHitProc);

                        if (v->internalOrBoundaryPoint())
                        {
                            parallelIntersectionIndices.append(vIndex);
                        }
                        else
                        {
                            parallelIntersectionIndices.append(-vIndex);
                        }

                        // Pout<< "Refer "
                        //     << parallelIntersectionPoints.last()
                        //     << " " << parallelIntersectionIndices.last()
                        //     << " " << closestHitProc
                        //     << endl;
                    }
                }
            }

            fIInner++;
        }

        fIOuter++;
    }

    referVertices
    (
        targetProcessor,
        parallelIntersectionPoints,
        parallelIntersectionIndices,
        receivedVertices,
        "intersection",
        outputName
    );
}


void Foam::conformalVoronoiMesh::buildParallelInterfaceInfluence
(
    List<labelHashSet>& referralVertices,
    List<labelHashSet>& receivedVertices,
    const word& outputName
)
{
    DynamicList<Foam::point> parallelInfluencePoints;
    DynamicList<label> targetProcessor;
    DynamicList<label> parallelInfluenceIndices;

    // Some of these values will not be used, i.e. for non-real cells
    DynamicList<Foam::point> circumcentre;
    DynamicList<scalar> circumradiusSqr;


    // Index outer (all) Delaunauy cells for whether they are potential
    // overlaps, index (inner) the list of tests an results.
    label cIInner = 0;
    label cIOuter = 0;

    seedProcessorBoundarySurfaces(true);

    label cellIndexCount = 0;
    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        cit->cellIndex() = cellIndexCount++;
    }


    timeCheck("End of cell Indexing");

    labelList testCellInfluence(number_of_cells(), 0);

    label nQuickRejections = 0;

    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        const Foam::point& cc = cit->dual();

        const scalar crSqr = magSqr(cc - topoint(cit->vertex(0)->point()));

        if
        (
            decomposition_().tree().quickCircumsphereRejection
            (
                cc,
                crSqr,
                decomposition_().octreeNearestDistances()
            )
        )
        {
            nQuickRejections++;
            //testCellInfluence[cit->cellIndex()] = -1;
        }
    }

    timeCheck("End of octreeNearestDistances calculation");

    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        // Assess the influence of the circumsphere of each Delaunay cell with
        // the defining volumes for all processors.  Any processor touched by
        // the circumsphere requires all points of the cell to be referred to
        // it.

        // The Delaunay cells to assess have to be real, i.e. all vertices form
        // part of the internal or any part of the boundary definition
        if
        (
            (testCellInfluence[cit->cellIndex()] == 0)
         && (cit->real() || cit->hasFarPoint())
        )
        {
            const Foam::point& cc = cit->dual();

            const scalar crSqr = magSqr(cc - topoint(cit->vertex(0)->point()));

            // Only if the circumsphere overlaps the boundary of this processor
            // is there a chance of it overlapping others
            if (decomposition_().overlapsThisProcessor(cc, sqr(1.01)*crSqr))
            {
                circumcentre.append(cc);
                circumradiusSqr.append(crSqr);

                testCellInfluence[cit->cellIndex()] = 1;
            }
        }

        cIOuter++;
    }

    timeCheck("End of testing cell influence");

//    Pout<< "Number of quick rejections = " << nQuickRejections << endl;
    Pout<< "Number of influences = " << circumcentre.size() << endl;

    // Increasing the circumspheres to increase the overlaps and compensate for
    // floating point errors missing some referrals
    labelListList circumsphereOverlaps
        = decomposition_().overlapsProcessors
          (
              circumcentre,
              sqr(1.01)*circumradiusSqr,
              false
          );

    timeCheck("End of increasing overlaps");

    // Reset counters
    cIOuter = 0;

    // Relying on the order of iteration of cells being the same as before
    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        // Pre-tested circumsphere potential influence
        if (testCellInfluence[cit->cellIndex()] == 1)
        {
            const labelList& citOverlaps = circumsphereOverlaps[cIInner];

            forAll(citOverlaps, cOI)
            {
                label procI = citOverlaps[cOI];

                for (int i = 0; i < 4; i++)
                {
                    Vertex_handle v = cit->vertex(i);

                    label vIndex = v->index();

                    if (v->farPoint() || v->referred())
                    {
                        continue;
                    }

                    // Using the hashSet to ensure that each vertex is only
                    // referred once to each processor
                    if (!referralVertices[procI].found(vIndex))
                    {
                        referralVertices[procI].insert(vIndex);

                        parallelInfluencePoints.append(topoint(v->point()));

                        targetProcessor.append(procI);

                        if (v->internalOrBoundaryPoint())
                        {
                            parallelInfluenceIndices.append(vIndex);
                        }
                        else
                        {
                            parallelInfluenceIndices.append(-vIndex);
                        }
                    }
                }
            }

            cIInner++;
        }

        cIOuter++;
    }

    label nFarPoints = removeProcessorBoundarySeeds(true);

    reduce(nFarPoints, sumOp<label>());

    Info<< "    Removed " << nFarPoints
        << " far points from the mesh." << endl;


//    seedProcessorBoundarySurfaces(false);

//    cIInner = 0;
//    cIOuter = 0;


    // Relying on the order of iteration of cells being the same as before
//    for
//    (
//        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
//        cit != finite_cells_end();
//        ++cit
//    )
//    {
//        // Pre-tested circumsphere potential influence
//        if (testCellInfluence[cIOuter])
//        {
//            const labelList& citOverlaps = circumsphereOverlaps[cIInner];
//
//            forAll(citOverlaps, cOI)
//            {
//                label procI = citOverlaps[cOI];
//
//                recursiveCircumsphereSearch
//                (
//                    cit,
//                    procI,
//                    referralVertices,
//                    checkedCells,
//                    parallelInfluencePoints,
//                    parallelInfluenceIndices,
//                    targetProcessor
//                );
//            }
//
//            cIInner++;
//        }
//
//        cIOuter++;
//    }

//    for
//    (
//        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
//        vit != finite_vertices_end();
//        ++vit
//    )
//    {
//        if (vit->referred())
//        {
//            //Pout << "REMOVE: " << topoint(vit->point()) << endl;
//            remove(vit);
//        }
//    }

    referVertices
    (
        targetProcessor,
        parallelInfluencePoints,
        parallelInfluenceIndices,
        receivedVertices,
        "influence",
        outputName
    );
}


void Foam::conformalVoronoiMesh::referVertices
(
    const DynamicList<label>& targetProcessor,
    DynamicList<Foam::point>& parallelPoints,
    DynamicList<label>& parallelIndices,
    List<labelHashSet>& receivedVertices,
    const word& stageName,
    const word& outputName
)
{
    timeCheck("Start of referVertices " + stageName);

    if (cvMeshControls().objOutput())
    {
        writePoints
        (
            "parallel_" + stageName +"_pointsToSend_" + outputName + ".obj",
            parallelPoints
        );
    }

    mapDistribute pointMap = backgroundMeshDecomposition::buildMap
    (
        targetProcessor
    );

    label totalVertices = parallelPoints.size();

    reduce(totalVertices, sumOp<label>());

    pointMap.distribute(parallelPoints);

    pointMap.distribute(parallelIndices);

    if (cvMeshControls().objOutput())
    {
        writePoints
        (
            "parallel_" + stageName +"_pointsReceived_" + outputName + ".obj",
            parallelPoints
        );
    }

    timeCheck("Start of referVertices " + stageName + " insertion.");

    label inserted = 0;

    for (label procI = 0; procI < Pstream::nProcs(); procI++)
    {
        const labelList& constructMap = pointMap.constructMap()[procI];

        if (constructMap.size())
        {
            forAll(constructMap, i)
            {
                label origIndex = parallelIndices[constructMap[i]];

                if (!receivedVertices[procI].found(origIndex))
                {
                    // For the initial referred vertices, the original
                    // processor is the one that is sending it.
                    label encodedProcI = Vb::encodeProcIndex(procI);

                    // Pout<< "Insert "
                    //     << parallelPoints[constructMap[i]]
                    //     << " " << origIndex
                    //     << " " << procI
                    //     << endl;

                    insertPoint
                    (
                        parallelPoints[constructMap[i]],
                        origIndex,
                        encodedProcI
                    );

                    inserted++;

                    receivedVertices[procI].insert(origIndex);
                }
            }
        }
    }

    reduce(inserted, sumOp<label>());

    Info<< "    Inserted " << stageName << " vertices " << inserted << endl;

    Info<< "    Total " << stageName << " vertices " << totalVertices << endl;

    timeCheck("End of referVertices " + stageName);
}


void Foam::conformalVoronoiMesh::dualCellLargestSurfaceProtrusion
(
    const Delaunay::Finite_vertices_iterator& vit,
    pointIndexHit& surfHitLargest,
    label& hitSurfaceLargest
) const
{
    // Set no-hit data
    surfHitLargest = pointIndexHit();
    hitSurfaceLargest = -1;

    std::list<Facet> facets;
    finite_incident_facets(vit, std::back_inserter(facets));

    const Foam::point vert = topoint(vit->point());

    scalar maxProtrusionDistance = maxSurfaceProtrusion(vert);

    for
    (
        std::list<Facet>::iterator fit = facets.begin();
        fit != facets.end();
        ++fit
    )
    {
        const Foam::point edgeMid =
            0.5
           *(
                fit->first->dual()
              + fit->first->neighbor(fit->second)->dual()
            );

        pointIndexHit surfHit;
        label hitSurface;

        geometryToConformTo_.findSurfaceAnyIntersection
        (
            vert,
            edgeMid,
            surfHit,
            hitSurface
        );

        if (surfHit.hit())
        {
            vectorField norm(1);

            allGeometry_[hitSurface].getNormal
            (
                List<pointIndexHit>(1, surfHit),
                norm
            );

            const vector& n = norm[0];

            const scalar normalProtrusionDistance =
                (edgeMid - surfHit.hitPoint()) & n;

            if (normalProtrusionDistance > maxProtrusionDistance)
            {
                surfHitLargest = surfHit;
                hitSurfaceLargest = hitSurface;

                maxProtrusionDistance = normalProtrusionDistance;
            }
        }
    }

    // Relying on short-circuit evaluation to not call for hitPoint when this
    // is a miss
    if
    (
        surfHitLargest.hit()
     && !positionOnThisProc(surfHitLargest.hitPoint())
    )
    {
        // A protrusion was identified, but not penetrating on this processor,
        // so set no-hit data and allow the other that should have this point
        // referred to generate it.
        surfHitLargest = pointIndexHit();
        hitSurfaceLargest = -1;
    }
}


void Foam::conformalVoronoiMesh::dualCellLargestSurfaceIncursion
(
    const Delaunay::Finite_vertices_iterator& vit,
    pointIndexHit& surfHitLargest,
    label& hitSurfaceLargest
) const
{
    // Set no-hit data
    surfHitLargest = pointIndexHit();
    hitSurfaceLargest = -1;

    std::list<Facet> facets;
    finite_incident_facets(vit, std::back_inserter(facets));

    const Foam::point vert = topoint(vit->point());

    scalar minIncursionDistance = -maxSurfaceProtrusion(vert);

    for
    (
        std::list<Facet>::iterator fit = facets.begin();
        fit != facets.end();
        ++fit
    )
    {
        const Foam::point edgeMid =
            0.5
           *(
                fit->first->dual()
              + fit->first->neighbor(fit->second)->dual()
            );

        pointIndexHit surfHit;
        label hitSurface;

        geometryToConformTo_.findSurfaceAnyIntersection
        (
            vert,
            edgeMid,
            surfHit,
            hitSurface
        );

        if (surfHit.hit())
        {
            vectorField norm(1);

            allGeometry_[hitSurface].getNormal
            (
                List<pointIndexHit>(1, surfHit),
                norm
            );

            const vector& n = norm[0];

            scalar normalIncursionDistance =
                (edgeMid - surfHit.hitPoint()) & n;

            if (normalIncursionDistance < minIncursionDistance)
            {
                surfHitLargest = surfHit;
                hitSurfaceLargest = hitSurface;

                minIncursionDistance = normalIncursionDistance;

                // Info<< nl << "# Incursion: " << endl;
                // meshTools::writeOBJ(Info, vert);
                // meshTools::writeOBJ(Info, edgeMid);
                // Info<< "l Na Nb" << endl;
            }
        }
    }

    // Relying on short-circuit evaluation to not call for hitPoint when this
    // is a miss
    if
    (
        surfHitLargest.hit()
     && !positionOnThisProc(surfHitLargest.hitPoint())
    )
    {
        // A protrusion was identified, but not penetrating on this processor,
        // so set no-hit data and allow the other that should have this point
        // referred to generate it.
        surfHitLargest = pointIndexHit();
        hitSurfaceLargest = -1;
    }
}


void Foam::conformalVoronoiMesh::reportProcessorOccupancy()
{
    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->real())
        {
            if (!positionOnThisProc(topoint(vit->point())))
            {
                Pout<< topoint(vit->point()) << " is not on this processor "
                    << endl;
            }
        }
    }
}


void Foam::conformalVoronoiMesh::reportSurfaceConformationQuality()
{
    Info<< nl << "Check surface conformation quality" << endl;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->internalOrBoundaryPoint())
        {
            Foam::point vert(topoint(vit->point()));
            pointIndexHit surfHit;
            label hitSurface;

            dualCellLargestSurfaceProtrusion(vit, surfHit, hitSurface);

            if (surfHit.hit())
            {
                Pout<< nl << "Residual penetration: " << nl
                    << vit->index() << nl
                    << vit->type() << nl
                    << vit->ppMaster() << nl
                    << "nearFeaturePt "
                    << nearFeaturePt(surfHit.hitPoint()) << nl
                    << vert << nl
                    << surfHit.hitPoint()
                    << endl;
            }
        }
    }

    {
        // Assess close surface points

        setVertexSizeAndAlignment();

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            if (vit->ppMaster())
            {
                std::list<Vertex_handle> adjacentVertices;

                adjacent_vertices(vit, std::back_inserter(adjacentVertices));

                Foam::point pt = topoint(vit->point());

                // Pout<< nl << "vit: " << vit->index() << " "
                //     << topoint(vit->point())
                //     << endl;

                // Pout<< adjacentVertices.size() << endl;

                for
                (
                    std::list<Vertex_handle>::iterator
                    avit = adjacentVertices.begin();
                    avit != adjacentVertices.end();
                    ++avit
                )
                {
                    Vertex_handle avh = *avit;

                    // The lower indexed vertex will perform the assessment
                    if
                    (
                        avh->ppMaster()
                     && vit->index() < avh->index()
                     && vit->type() != avh->type()
                    )
                    {
                        scalar targetSize = 0.2*averageAnyCellSize(vit, avh);

                        // Pout<< "diff " << mag(pt - topoint(avh->point()))
                        //     << " " << targetSize << endl;

                        if
                        (
                            magSqr(pt - topoint(avh->point()))
                          < sqr(targetSize)
                        )
                        {
                            Pout<< nl << "vit: " << vit->index() << " "
                                << topoint(vit->point())
                                << endl;

                            Pout<< "    adjacent too close: "
                                << avh->index() << " "
                                << topoint(avh->point())
                                << endl;
                        }
                    }
                }
            }
        }
    }
}


void Foam::conformalVoronoiMesh::limitDisplacement
(
    const Delaunay::Finite_vertices_iterator& vit,
    vector& displacement,
    label callCount
) const
{
    callCount++;

    // Do not allow infinite recursion
    if (callCount > 7)
    {
        return;
    }

    Foam::point pt = topoint(vit->point());
    Foam::point dispPt = pt + displacement;

    bool limit = false;

    pointIndexHit surfHit;
    label hitSurface;

    if (!geometryToConformTo_.globalBounds().contains(dispPt))
    {
        // If dispPt is outside bounding box then displacement cuts boundary
        limit = true;
    }
    else if (geometryToConformTo_.findSurfaceAnyIntersection(pt, dispPt))
    {
        // Full surface penetration test
        limit = true;
    }
    else
    {
        // Testing if the displaced position is too close to the surface.
        // Within twice the local surface point pair insertion distance is
        // considered "too close"

        scalar searchDistanceSqr = sqr
        (
            2*vit->targetCellSize()
           *cvMeshControls().pointPairDistanceCoeff()
        );

        geometryToConformTo_.findSurfaceNearest
        (
            dispPt,
            searchDistanceSqr,
            surfHit,
            hitSurface
        );

        if (surfHit.hit())
        {
            limit = true;

            if (magSqr(pt - surfHit.hitPoint()) <= searchDistanceSqr)
            {
                // Cannot limit displacement, point closer than tolerance
                return;
            }
        }
    }

    if (limit)
    {
        // Halve the displacement and call this function again.  Will continue
        // recursively until the displacement is small enough.

        displacement *= 0.5;

        limitDisplacement(vit, displacement, callCount);
    }
}


Foam::scalar Foam::conformalVoronoiMesh::angleBetweenSurfacePoints
(
    Foam::point pA,
    Foam::point pB
) const
{
    pointIndexHit pAhit;
    label pAsurfaceHit = -1;

    const scalar searchDist = 5.0*targetCellSize(pA);

    geometryToConformTo_.findSurfaceNearest
    (
        pA,
        searchDist,
        pAhit,
        pAsurfaceHit
    );

    vectorField norm(1);

    allGeometry_[pAsurfaceHit].getNormal
    (
        List<pointIndexHit>(1, pAhit),
        norm
    );

    const vector nA = norm[0];

    pointIndexHit pBhit;
    label pBsurfaceHit = -1;

    geometryToConformTo_.findSurfaceNearest
    (
        pB,
        searchDist,
        pBhit,
        pBsurfaceHit
    );

    allGeometry_[pBsurfaceHit].getNormal
    (
        List<pointIndexHit>(1, pBhit),
        norm
    );

    const vector nB = norm[0];

    return vectorTools::cosPhi(nA, nB);
}


bool Foam::conformalVoronoiMesh::nearSurfacePoint
(
    pointIndexHit& pHit,
    label& surfaceHit,
    DynamicList<Foam::point>& existingSurfacePtLocations
) const
{
    const Foam::point& pt = pHit.hitPoint();

    pointIndexHit closePoint;

    const bool closeToSurfacePt = pointIsNearSurfaceLocation(pt, closePoint);

    if (closeToSurfacePt)
    {
        const scalar cosAngle
            = angleBetweenSurfacePoints(pt, closePoint.hitPoint());

        // @todo make this tolerance run-time selectable?
        if (cosAngle < searchAngleOppositeSurface)
        {
            pointIndexHit pCloseHit;
            label pCloseSurfaceHit = -1;

            const scalar searchDist = targetCellSize(closePoint.hitPoint());

            geometryToConformTo_.findSurfaceNearest
            (
                closePoint.hitPoint(),
                searchDist,
                pCloseHit,
                pCloseSurfaceHit
            );

            vectorField norm(1);

            allGeometry_[pCloseSurfaceHit].getNormal
            (
                List<pointIndexHit>(1, pCloseHit),
                norm
            );

            const vector nA = norm[0];

            pointIndexHit oppositeHit;
            label oppositeSurfaceHit = -1;

            geometryToConformTo_.findSurfaceNearestIntersection
            (
                closePoint.hitPoint() + SMALL*nA,
                closePoint.hitPoint() + mag(pt - closePoint.hitPoint())*nA,
                oppositeHit,
                oppositeSurfaceHit
            );

            if (oppositeHit.hit())
            {
                // Replace point
                pHit = oppositeHit;
                surfaceHit = oppositeSurfaceHit;

                Foam::point newPt = oppositeHit.hitPoint();

                appendToSurfacePtTree(newPt, existingSurfacePtLocations);

                return !closeToSurfacePt;

                if (debug)
                {
                    Info<< "Point " << pt
                        << " is close to " << closePoint.hitPoint()
                        << " so will be moved to " << oppositeHit.hitPoint()
                        << endl;
                }
            }
        }
    }
    else
    {
        appendToSurfacePtTree(pt, existingSurfacePtLocations);
    }

    return closeToSurfacePt;
}


bool Foam::conformalVoronoiMesh::appendToSurfacePtTree
(
    const Foam::point& pt,
    DynamicList<Foam::point>& existingSurfacePtLocations
) const
{
   label startIndex = existingSurfacePtLocations.size();

   existingSurfacePtLocations.append(pt);

   label endIndex = existingSurfacePtLocations.size();

   return surfacePtLocationTreePtr_().insert(startIndex, endIndex);
}


bool Foam::conformalVoronoiMesh::appendToEdgeLocationTree
(
    const Foam::point& pt,
    DynamicList<Foam::point>& existingEdgeLocations
) const
{
   label startIndex = existingEdgeLocations.size();

   existingEdgeLocations.append(pt);

   label endIndex = existingEdgeLocations.size();

   return edgeLocationTreePtr_().insert(startIndex, endIndex);
}


Foam::List<Foam::pointIndexHit>
Foam::conformalVoronoiMesh::nearestFeatureEdgeLocations
(
    const Foam::point& pt
) const
{
    const scalar exclusionRangeSqr = featureEdgeExclusionDistanceSqr(pt);

    labelList elems
        = edgeLocationTreePtr_().findSphere(pt, exclusionRangeSqr);

    DynamicList<pointIndexHit> dynPointHit;

    forAll(elems, elemI)
    {
        label index = elems[elemI];

        const Foam::point& pointI
            = edgeLocationTreePtr_().shapes().shapePoints()[index];

        pointIndexHit nearHit(true, pointI, index);

        dynPointHit.append(nearHit);
    }

    return dynPointHit;
}


bool Foam::conformalVoronoiMesh::pointIsNearFeatureEdgeLocation
(
    const Foam::point& pt
) const
{
    const scalar exclusionRangeSqr = featureEdgeExclusionDistanceSqr(pt);

    pointIndexHit info
        = edgeLocationTreePtr_().findNearest(pt, exclusionRangeSqr);

    return info.hit();
}


bool Foam::conformalVoronoiMesh::pointIsNearFeatureEdgeLocation
(
    const Foam::point& pt,
    pointIndexHit& info
) const
{
    const scalar exclusionRangeSqr = featureEdgeExclusionDistanceSqr(pt);

    info = edgeLocationTreePtr_().findNearest(pt, exclusionRangeSqr);

    return info.hit();
}


bool Foam::conformalVoronoiMesh::pointIsNearSurfaceLocation
(
    const Foam::point& pt
) const
{
    pointIndexHit info;

    pointIsNearSurfaceLocation(pt, info);

    return info.hit();
}


bool Foam::conformalVoronoiMesh::pointIsNearSurfaceLocation
(
    const Foam::point& pt,
    pointIndexHit& info
) const
{
    const scalar exclusionRangeSqr = surfacePtExclusionDistanceSqr(pt);

    info = surfacePtLocationTreePtr_().findNearest(pt, exclusionRangeSqr);

    return info.hit();
}


bool Foam::conformalVoronoiMesh::nearFeatureEdgeLocation
(
    pointIndexHit& pHit,
    DynamicList<Foam::point>& existingEdgeLocations
) const
{
    Foam::point pt = pHit.hitPoint();

    const scalar exclusionRangeSqr = featureEdgeExclusionDistanceSqr(pt);

    bool closeToFeatureEdge = pointIsNearFeatureEdgeLocation(pt);

    if (closeToFeatureEdge)
    {
        List<pointIndexHit> nearHits = nearestFeatureEdgeLocations(pt);

        forAll(nearHits, elemI)
        {
            pointIndexHit& info = nearHits[elemI];

            // Check if the edge location that the new edge location is near to
            // "might" be on a different edge. If so, add it anyway.
            pointIndexHit edgeHit;
            label featureHit = -1;

            geometryToConformTo_.findEdgeNearest
            (
                pt,
                exclusionRangeSqr,
                edgeHit,
                featureHit
            );

            const extendedFeatureEdgeMesh& eMesh
                = geometryToConformTo_.features()[featureHit];

            const vector& edgeDir = eMesh.edgeDirections()[edgeHit.index()];

            const vector lineBetweenPoints = pt - info.hitPoint();

            const scalar cosAngle
                = vectorTools::cosPhi(edgeDir, lineBetweenPoints);

            // Allow the point to be added if it is almost at right angles to
            // the other point. Also check it is not the same point.
    //        Info<< cosAngle<< " "
    //            << radToDeg(acos(cosAngle)) << " "
    //            << searchConeAngle << " "
    //            << radToDeg(acos(searchConeAngle)) << endl;

            if
            (
                mag(cosAngle) < searchConeAngle
             && (
                    mag(lineBetweenPoints)
                  > cvMeshControls().pointPairDistanceCoeff()*targetCellSize(pt)
                )
            )
            {
                pt = edgeHit.hitPoint();
                pHit.setPoint(pt);
                closeToFeatureEdge = false;
            }
            else
            {
                closeToFeatureEdge = true;
                break;
            }
        }
    }

    if (!closeToFeatureEdge)
    {
        appendToEdgeLocationTree(pt, existingEdgeLocations);
    }

    return closeToFeatureEdge;
}


void Foam::conformalVoronoiMesh::buildEdgeLocationTree
(
    const DynamicList<Foam::point>& existingEdgeLocations
) const
{
    treeBoundBox overallBb
    (
        geometryToConformTo_.globalBounds().extend(rndGen_, 1e-4)
    );

    overallBb.min() -= Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);
    overallBb.max() += Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);

    edgeLocationTreePtr_.reset
    (
        new dynamicIndexedOctree<dynamicTreeDataPoint>
        (
            dynamicTreeDataPoint(existingEdgeLocations),
            overallBb,  // overall search domain
            10,         // max levels, n/a
            20.0,       // maximum ratio of cubes v.s. cells
            100.0       // max. duplicity; n/a since no bounding boxes.
        )
    );
}


void Foam::conformalVoronoiMesh::buildSurfacePtLocationTree
(
    const DynamicList<Foam::point>& existingSurfacePtLocations
) const
{
    treeBoundBox overallBb
    (
        geometryToConformTo_.globalBounds().extend(rndGen_, 1e-4)
    );

    overallBb.min() -= Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);
    overallBb.max() += Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);

    surfacePtLocationTreePtr_.reset
    (
        new dynamicIndexedOctree<dynamicTreeDataPoint>
        (
            dynamicTreeDataPoint(existingSurfacePtLocations),
            overallBb,  // overall search domain
            10,         // max levels, n/a
            20.0,       // maximum ratio of cubes v.s. cells
            100.0       // max. duplicity; n/a since no bounding boxes.
        )
    );
}


void Foam::conformalVoronoiMesh::buildSizeAndAlignmentTree() const
{
    if (sizeAndAlignmentLocations_.empty())
    {
        FatalErrorIn("buildSizeAndAlignmentTree()")
            << "sizeAndAlignmentLocations empty, must be populated before "
            << "sizeAndAlignmentTree can be built."
            << exit(FatalError);
    }

    treeBoundBox overallBb
    (
        geometryToConformTo_.globalBounds().extend(rndGen_, 1e-4)
    );

    overallBb.min() -= Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);
    overallBb.max() += Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);

    sizeAndAlignmentTreePtr_.reset
    (
        new indexedOctree<treeDataPoint>
        (
            treeDataPoint(sizeAndAlignmentLocations_),
            overallBb,  // overall search domain
            10,         // max levels
            20.0,       // maximum ratio of cubes v.s. cells
            100.0       // max. duplicity; n/a since no bounding boxes.
        )
    );
}


void Foam::conformalVoronoiMesh::addSurfaceAndEdgeHits
(
    const Delaunay::Finite_vertices_iterator& vit,
    const Foam::point& vert,
    const DynamicList<pointIndexHit>& surfHit,
    const DynamicList<label>& hitSurface,
    scalar surfacePtReplaceDistCoeffSqr,
    scalar edgeSearchDistCoeffSqr,
    DynamicList<pointIndexHit>& surfaceHits,
    DynamicList<label>& hitSurfaces,
    DynamicList<pointIndexHit>& featureEdgeHits,
    DynamicList<label>& featureEdgeFeaturesHit,
    DynamicList<Foam::point>& newEdgeLocations,
    DynamicList<Foam::point>& existingEdgeLocations,
    DynamicList<Foam::point>& existingSurfacePtLocations
) const
{
    const scalar cellSize = targetCellSize(vert);
    const scalar cellSizeSqr = sqr(cellSize);

    forAll(surfHit, sI)
    {
        bool keepSurfacePoint = true;

        pointIndexHit surfHitI = surfHit[sI];
        label hitSurfaceI = hitSurface[sI];

        if (!surfHitI.hit())
        {
            continue;
        }

        bool isNearFeaturePt = nearFeaturePt(surfHitI.hitPoint());

        bool isNearSurfacePt = nearSurfacePoint
        (
            surfHitI,
            hitSurfaceI,
            existingSurfacePtLocations
        );

        if (isNearFeaturePt || isNearSurfacePt)
        {
            keepSurfacePoint = false;

            // If the triggering Vertex is part of a feature point, allow it to
            // conform to the surface.
            // @todo Is this needed?! Shouldn't be any feature points here...
            if (vit->index() < startOfInternalPoints_)
            {
                surfaceHits.append(surfHitI);

                hitSurfaces.append(hitSurfaceI);
            }
        }

        List<List<pointIndexHit> > edHitsByFeature;

        labelList featuresHit;

        const scalar searchRadiusSqr = edgeSearchDistCoeffSqr*cellSizeSqr;

        geometryToConformTo_.findAllNearestEdges
        (
            surfHitI.hitPoint(),
            searchRadiusSqr,
            edHitsByFeature,
            featuresHit
        );

        forAll(edHitsByFeature, i)
        {
            const label featureHit = featuresHit[i];

            List<pointIndexHit>& edHits = edHitsByFeature[i];

            forAll(edHits, eHitI)
            {
                pointIndexHit& edHit = edHits[eHitI];

                if (edHit.hit())
                {
                    if (!nearFeaturePt(edHit.hitPoint()))
                    {
                        if
                        (
                            magSqr(edHit.hitPoint() - surfHitI.hitPoint())
                          < surfacePtReplaceDistCoeffSqr*cellSizeSqr
                        )
                        {
                            // If the point is within a given distance of a
                            // feature edge, give control to edge control points
                            // instead, this will prevent "pits" forming.

                            keepSurfacePoint = false;

                            // NEED TO REMOVE FROM THE SURFACE TREE...
                            surfacePtLocationTreePtr_().remove
                            (
                                existingSurfacePtLocations.size() - 1
                            );
                        }

                        if
                        (
                            !nearFeatureEdgeLocation
                            (
                                edHit,
                                existingEdgeLocations
                            )
                        )
                        {
                            // Do not place edge control points too close to a
                            // feature point or existing edge control points
                            featureEdgeHits.append(edHit);
                            featureEdgeFeaturesHit.append(featureHit);
                        }
                    }
                }
            }
        }

        if (keepSurfacePoint)
        {
            surfaceHits.append(surfHitI);
            hitSurfaces.append(hitSurfaceI);
        }
    }
}


void Foam::conformalVoronoiMesh::storeSurfaceConformation()
{
    Info<< nl << "Storing surface conformation" << endl;

    surfaceConformationVertices_.clear();

    // Use a temporary dynamic list to speed up insertion.
    DynamicList<Vb> tempSurfaceVertices(number_of_vertices()/10);

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        // Store points that are not referred, part of a pair, but not feature
        // points
        if
        (
            !vit->referred()
         && vit->pairPoint()
         && vit->index() >= startOfInternalPoints_
        )
        {
            tempSurfaceVertices.append
            (
                Vb
                (
                    vit->point(),
                    0,                          // index, reset to zero
                    vit->type() - vit->index()  // type, relative to index
                )
            );
        }
    }

    tempSurfaceVertices.shrink();

    surfaceConformationVertices_.transfer(tempSurfaceVertices);

    Info<< "    Stored "
        << returnReduce
        (
            label(surfaceConformationVertices_.size()),
            sumOp<label>()
        )
        << " vertices" << endl;
}


void Foam::conformalVoronoiMesh::reinsertSurfaceConformation()
{
    Info<< nl << "Reinserting stored surface conformation" << endl;

    label preReinsertionSize(number_of_vertices());

    // It is assumed that the stored surface conformation is on the correct
    // processor and does not need distributed

    for
    (
        List<Vb>::iterator vit=surfaceConformationVertices_.begin();
        vit != surfaceConformationVertices_.end();
        ++vit
    )
    {
        // Assuming that all of the reinsertions are pair points, and that the
        // index and type are relative, i.e. index 0 and type relative to it.
        insertPoint
        (
            vit->point(),
            vit->index() + number_of_vertices(),
            vit->type() + number_of_vertices()
        );
    }

    Info<< "    Reinserted "
        << returnReduce
        (
            label(number_of_vertices()) - preReinsertionSize,
            sumOp<label>()
        )
        << " vertices" << endl;
}


// ************************************************************************* //
