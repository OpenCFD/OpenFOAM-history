/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2011 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "conformalVoronoiMesh.H"
#include "initialPointsMethod.H"
#include "relaxationModel.H"
#include "faceAreaWeightModel.H"
#include "backgroundMeshDecomposition.H"
#include "meshSearch.H"

// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

namespace Foam
{

defineTypeNameAndDebug(conformalVoronoiMesh, 0);

}

const Foam::scalar Foam::conformalVoronoiMesh::tolParallel = 1e-3;


// * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * * //

Foam::tensor Foam::conformalVoronoiMesh::requiredAlignment
(
    const Foam::point& pt
) const
{
    pointIndexHit surfHit;
    label hitSurface;

    geometryToConformTo_.findSurfaceNearest
    (
        pt,
        sqr(GREAT),
        surfHit,
        hitSurface
    );

    if (!surfHit.hit())
    {
        FatalErrorIn
        (
            "Foam::tensor Foam::conformalVoronoiMesh::requiredAlignment"
        )
            << "findSurfaceNearest did not find a hit across the surfaces."
            << exit(FatalError) << endl;
    }

    // Primary alignment

    vectorField norm(1);

    allGeometry_[hitSurface].getNormal
    (
        List<pointIndexHit>(1, surfHit),
        norm
    );

    const vector np = norm[0];

    // Generate equally spaced 'spokes' in a circle normal to the
    // direction from the vertex to the closest point on the surface
    // and look for a secondary intersection.

    const vector d = surfHit.hitPoint() - pt;

    const tensor Rp = rotationTensor(vector(0,0,1), np);

    const label s = cvMeshControls().alignmentSearchSpokes();

    scalar closestSpokeHitDistance = GREAT;

    pointIndexHit closestSpokeHit;

    label closestSpokeSurface = -1;

    const scalar spanMag = geometryToConformTo_.globalBounds().mag();

    for (label i = 0; i < s; i++)
    {
        vector spoke
        (
            Foam::cos(i*constant::mathematical::twoPi/s),
            Foam::sin(i*constant::mathematical::twoPi/s),
            0
        );

        spoke *= spanMag;

        spoke = Rp & spoke;

        pointIndexHit spokeHit;

        label spokeSurface = -1;

        // internal spoke

        geometryToConformTo_.findSurfaceNearestIntersection
        (
            pt,
            pt + spoke,
            spokeHit,
            spokeSurface
        );

        if (spokeHit.hit())
        {
            scalar spokeHitDistance = mag
            (
                spokeHit.hitPoint() - pt
            );

            if (spokeHitDistance < closestSpokeHitDistance)
            {
                closestSpokeHit = spokeHit;
                closestSpokeSurface = spokeSurface;
                closestSpokeHitDistance = spokeHitDistance;
            }
        }

        //external spoke

        Foam::point mirrorPt = pt + 2*d;

        geometryToConformTo_.findSurfaceNearestIntersection
        (
            mirrorPt,
            mirrorPt + spoke,
            spokeHit,
            spokeSurface
        );

        if (spokeHit.hit())
        {
            scalar spokeHitDistance = mag
            (
                spokeHit.hitPoint() - mirrorPt
            );

            if (spokeHitDistance < closestSpokeHitDistance)
            {
                closestSpokeHit = spokeHit;
                closestSpokeSurface = spokeSurface;
                closestSpokeHitDistance = spokeHitDistance;
            }
        }
    }

    if (closestSpokeSurface == -1)
    {
        WarningIn
        (
            "conformalVoronoiMesh::requiredAlignment"
            "("
                "const Foam::point& pt"
            ") const"
        )   << "No secondary surface hit found in spoke search "
            << "using " << s
            << " spokes, try increasing alignmentSearchSpokes."
            << endl;

        return I;
    }

    // Auxiliary alignment generated by spoke intersection normal.

    allGeometry_[closestSpokeSurface].getNormal
    (
        List<pointIndexHit>(1, closestSpokeHit),
        norm
    );

    const vector& na = norm[0];

    // Secondary alignment
    vector ns = np ^ na;

    if (mag(ns) < SMALL)
    {
        FatalErrorIn("conformalVoronoiMesh::requiredAlignment")
            << "Parallel normals detected in spoke search." << nl
            << "point: " << pt << nl
            << "closest surface point: " << surfHit.hitPoint() << nl
            << "closest spoke hit: " << closestSpokeHit.hitPoint() << nl
            << "np: " << surfHit.hitPoint() + np << nl
            << "ns: " << closestSpokeHit.hitPoint() + na << nl
            << exit(FatalError);
    }

    ns /= mag(ns);

    tensor Rs = rotationTensor((Rp & vector(0,1,0)), ns);

    return (Rs & Rp);
}


void Foam::conformalVoronoiMesh::insertPoints
(
    List<Point>& points,
    bool distribute
)
{
    label preInsertionSize(number_of_vertices());

    label nPoints = points.size();

    if (Pstream::parRun())
    {
        reduce(nPoints, sumOp<label>());
    }

    Info<< "    " << nPoints << " points to insert..." << endl;

    if (Pstream::parRun() && distribute)
    {
        label preDistributionSize(points.size());

        DynamicList<Foam::point> transferPoints(points.size()/2);

        DynamicList<Point> pointsOnProcessor(points.size()/2);

        for
        (
            List<Point>::iterator pit = points.begin();
            pit != points.end();
            ++pit
        )
        {
            Foam::point p(topoint(*pit));

            if (!positionOnThisProc(p))
            {
                transferPoints.append(p);
            }
            else
            {
                pointsOnProcessor.append(*pit);
            }
        }

        points.setSize(pointsOnProcessor.size());
        forAll(pointsOnProcessor, pI)
        {
            points[pI] = pointsOnProcessor[pI];
        }
        pointsOnProcessor.clear();

        // Send the points that are not on this processor to the appropriate
        // place
        Foam::autoPtr<Foam::mapDistribute> map
        (
            decomposition_().distributePoints(transferPoints)
        );

        forAll(transferPoints, tPI)
        {
            points.append(toPoint(transferPoints[tPI]));
        }

        label sizeChange = preDistributionSize - label(points.size());

        // if (mag(sizeChange) > 0)
        // {
        //     Pout<< "    distribution points size change " << sizeChange
        //         << endl;
        // }

        label totalMagSizeChange = returnReduce
        (
            mag(sizeChange), sumOp<label>()
        );

        if (totalMagSizeChange > 0)
        {
            Info<< "    distribution points size change total "
                << totalMagSizeChange/2
                << endl;
        }

        nPoints = points.size();

        reduce(nPoints, sumOp<label>());

        Info<< "    " << nPoints
            << " points to insert after distribution..." << endl;
    }

    label nVert = number_of_vertices();

    // using the range insert (faster than inserting points one by one)
    insert(points.begin(), points.end());

//     Info<< "USING INDIVIDUAL INSERTION TO DETECT FAILURE" << endl;
//     for
//     (
//         List<Point>::iterator pit=points.begin();
//         pit != points.end();
//         ++pit
//     )
//     {
//         insertPoint(topoint(*pit), Vb::vtInternal);
//     }

    label nInserted(number_of_vertices() - preInsertionSize);

    if (Pstream::parRun())
    {
        reduce(nInserted, sumOp<label>());
    }

    Info<< "    " << nInserted << " points inserted" << endl;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->uninitialised())
        {
            vit->index() = nVert++;
        }
    }
}


void Foam::conformalVoronoiMesh::insertPoints
(
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types,
    bool distribute
)
{
    // The pts, indices and types lists must be intact and up-to-date at the
    // end of this function as they may also be used by other functions
    // subsequently.

    if (Pstream::parRun() && distribute)
    {
        // The link between vertices that form the boundary via pairs cannot be
        // strict because both points may end up on different processors.  The
        // only important thing is that each vertex knows its own role.
        // Therefore, index and type are set to 0 or 1, then on the destination
        // processor add back the new index to both.

        // Each of points generated in this process are pair points, so there
        // is no risk of underflowing "type".

        // Pout<< "Points before "
        //     << pts.size() << " " << indices.size() << " " << types.size()
        //     << endl;

        // Distribute points to their appropriate processor
        autoPtr<mapDistribute> map
        (
            decomposition_().distributePoints(pts)
        );

        map().distribute(indices);
        map().distribute(types);

        // Pout<< "Points after "
        //     << pts.size() << " " << indices.size() << " " << types.size()
        //     << endl;

        // Info<< returnReduce(pts.size(), sumOp<label>())
        //     << " points in total" << endl;
    }
//
//    forAll(pts, pI)
//    {
//        // creation of points and indices is done assuming that it will be
//        // relative to the instantaneous number_of_vertices() at insertion.
//
//        label type = types[pI];
//
//        if (type > Vb::vtFar)
//        {
//            // This is a member of a point pair, don't use the type directly
//            // (note that this routine never gets called for referredPoints
//            //  so type will never be -procI)
//            type += number_of_vertices();
//        }
//
//        insertPoint
//        (
//            pts[pI],
//            indices[pI] + number_of_vertices(),
//            type
//        );
//    }


    rangeInsertWithInfo
    (
        pts.begin(),
        pts.end(),
        *this,
        indices,
        types
    );

    Pout<< pts.size() << " " << indices.size() << " " << types.size() << endl;
}


void Foam::conformalVoronoiMesh::insertSurfacePointPairs
(
    const List<pointIndexHit>& surfaceHits,
    const List<label>& hitSurfaces,
    const fileName fName
)
{
    if (surfaceHits.size() != hitSurfaces.size())
    {
        FatalErrorIn("Foam::conformalVoronoiMesh::insertPointPairs")
            << "surfaceHits and hitSurfaces are not the same size. Sizes "
            << surfaceHits.size() << ' '
            << hitSurfaces.size()
            << exit(FatalError);
    }

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    forAll(surfaceHits, i)
    {
        vectorField norm(1);

        allGeometry_[hitSurfaces[i]].getNormal
        (
            List<pointIndexHit>(1, surfaceHits[i]),
            norm
        );

        const vector& normal = norm[0];

        const Foam::point& surfacePt(surfaceHits[i].hitPoint());

        createPointPair
        (
            pointPairDistance(surfacePt),
            surfacePt,
            normal,
            pts,
            indices,
            types
        );
    }

    insertPoints(pts, indices, types, true);

    if (cvMeshControls().objOutput() && fName != fileName::null)
    {
        writePoints(fName, pts);
    }
}


void Foam::conformalVoronoiMesh::insertEdgePointGroups
(
    const List<pointIndexHit>& edgeHits,
    const labelList& featuresHit,
    const fileName fName
)
{
    if (edgeHits.size() != featuresHit.size())
    {
        FatalErrorIn("Foam::conformalVoronoiMesh::insertEdgePointGroups")
            << "edgeHits and featuresHit are not the same size. Sizes "
            << edgeHits.size() << ' '
            << featuresHit.size()
            << exit(FatalError);
    }

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    forAll(edgeHits, i)
    {
        const extendedFeatureEdgeMesh& feMesh
        (
            geometryToConformTo_.features()[featuresHit[i]]
        );

        createEdgePointGroup(feMesh, edgeHits[i], pts, indices, types);
    }

    insertPoints(pts, indices, types, true);

    if (cvMeshControls().objOutput() && fName != fileName::null)
    {
        writePoints(fName, pts);
    }
}


const Foam::indexedOctree<Foam::treeDataPoint>&
Foam::conformalVoronoiMesh::featurePointTree() const
{
    if (featurePointTreePtr_.empty())
    {
        treeBoundBox overallBb
        (
            geometryToConformTo_.globalBounds().extend(rndGen_, 1e-4)
        );

        overallBb.min() -= Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);
        overallBb.max() += Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);

        featurePointTreePtr_.reset
        (
            new indexedOctree<treeDataPoint>
            (
                treeDataPoint(featurePointLocations_),
                overallBb,  // overall search domain
                10,         // max levels
                10.0,       // maximum ratio of cubes v.s. cells
                100.0       // max. duplicity; n/a since no bounding boxes.
            )
        );
    }

    return featurePointTreePtr_();
}


bool Foam::conformalVoronoiMesh::nearFeaturePt(const Foam::point& pt) const
{
    const indexedOctree<treeDataPoint>& tree = featurePointTree();

    scalar exclusionRangeSqr = featurePointExclusionDistanceSqr(pt);

    pointIndexHit info = tree.findNearest(pt, exclusionRangeSqr);

    return info.hit();
}


void Foam::conformalVoronoiMesh::reset(const bool distribute)
{
    this->clear();

    reinsertBoundingPoints();

    // Reinsert feature points, distributing them as necessary.
    reinsertFeaturePoints(distribute);
    //insertFeaturePoints();

    startOfInternalPoints_ = number_of_vertices();
}


void Foam::conformalVoronoiMesh::insertInitialPoints()
{
    Info<< nl << "Inserting initial points" << endl;

    timeCheck("Before initial points call");

    List<Point> initPts = initialPointsMethod_->initialPoints();

    timeCheck("After initial points call");

    // Assume that the initial points method made the correct decision for
    // which processor each point should be on, so give distribute = false
    insertPoints(initPts, false);

    if (cvMeshControls().objOutput())
    {
        writePoints("initialPoints.obj", true);
    }

}


bool Foam::conformalVoronoiMesh::distributeBackground()
{
    if (!Pstream::parRun())
    {
        return false;
    }

    Info<< nl << "Redistributing points" << endl;

    timeCheck("Before distribute");

    label iteration = 0;

    while (true)
    {
        label nRealVertices = 0;

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            // Only store real vertices that are not feature vertices
            if (vit->real() && vit->index() >= startOfInternalPoints_)
            {
                nRealVertices++;
            }
        }

        scalar globalNRealVertices = returnReduce
        (
            nRealVertices,
            sumOp<label>()
        );

        scalar unbalance = returnReduce
        (
            mag(1.0 - nRealVertices/(globalNRealVertices/Pstream::nProcs())),
            maxOp<scalar>()
        );

        Info<< "    Processor unbalance " << unbalance << endl;

        if (unbalance <= cvMeshControls().maxLoadUnbalance())
        {
            // If this is the first iteration, return false, if it was a
            // subsequent one, return true;
            return iteration != 0;
        }

        Info<< "    Total number of vertices before redistribution "
            << returnReduce(label(number_of_vertices()), sumOp<label>())
            << endl;

        // Pout<< "    Real vertices before distribution "
        //     << nRealVertices << endl;

        const fvMesh& bMesh = decomposition_().mesh();

        volScalarField cellWeights
        (
            IOobject
            (
                "cellWeights",
                bMesh.time().timeName(),
                bMesh,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            bMesh,
            dimensionedScalar("weight", dimless, 1e-2),
            zeroGradientFvPatchScalarField::typeName
        );

        meshSearch cellSearch(bMesh, polyMesh::FACEPLANES);

        List<DynamicList<Foam::point> > cellVertices(bMesh.nCells());
        List<DynamicList<label> > cellVertexIndices(bMesh.nCells());
        List<DynamicList<label> > cellVertexTypes(bMesh.nCells());

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            // Only store real vertices that are not feature vertices
            if (vit->real() && vit->index() >= startOfInternalPoints_)
            {
                Foam::point v = topoint(vit->point());

                label cellI = cellSearch.findCell(v);

                if (cellI == -1)
                {
                    // Pout<< "findCell conformalVoronoiMesh::distribute "
                    //     << "findCell "
                    //     << vit->type() << " "
                    //     << vit->index() << " "
                    //     << v << " "
                    //     << cellI
                    //     << " find nearest cellI ";

                    cellI = cellSearch.findNearestCell(v);

                    Pout<< cellI << endl;
                }

                cellVertices[cellI].append(topoint(vit->point()));
                cellVertexIndices[cellI].append(vit->index());
                cellVertexTypes[cellI].append(vit->type());
            }
        }

        forAll(cellVertices, cI)
        {
            // Give a small but finite weight for empty cells.  Some
            // decomposition methods have difficulty with integer overflows in
            // the sum of the normalised weight field.
            cellWeights.internalField()[cI] = max
            (
                cellVertices[cI].size(),
                1e-2
            );
        }

        autoPtr<mapDistributePolyMesh> mapDist = decomposition_().distribute
        (
            cellWeights,
            cellVertices,
            cellVertexIndices,
            cellVertexTypes
        );

        // Reset the entire tessellation
        reset(true);

        timeCheck("Distribution performed");

        Info<< nl << "    Inserting distributed tessellation" << endl;

        DynamicList<Foam::point> pointsToInsert;
        DynamicList<label> indices;
        DynamicList<label> types;

        forAll(cellVertices, cI)
        {
            forAll(cellVertices[cI], cVPI)
            {
                pointsToInsert.append(cellVertices[cI][cVPI]);

                // All insertions relative to index of zero
                indices.append(0);

                label type = cellVertexTypes[cI][cVPI];

                if (type > Vb::vtFar)
                {
                    // This is a member of a point pair, don't use the type
                    // directly, make type relative to the index in preparation
                    // for insertion.

                    type -= cellVertexIndices[cI][cVPI];
                }

                types.append(type);
            }
        }

        // Assume that the distribution made the correct decision for which
        // processor each point should be on, so give distribute = false
        insertPoints(pointsToInsert, indices, types, false);

        Info<< "    Total number of vertices after redistribution "
            << returnReduce(label(number_of_vertices()), sumOp<label>())
            << endl;

        // Pout<< "    Real vertices after distribution "
        //     << label(number_of_vertices() - 8) << endl;

        if (cvMeshControls().objOutput())
        {
            writePoints("distributedPoints.obj", true);
        }

        timeCheck("After distribute");

        iteration++;
    }

    return true;
}


void Foam::conformalVoronoiMesh::storeSizesAndAlignments()
{
    DynamicList<Point> storePts(number_of_vertices());

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->internalPoint())
        {
            storePts.append(vit->point());
        }
    }

    storePts.shrink();

    storeSizesAndAlignments(storePts);
}


void Foam::conformalVoronoiMesh::storeSizesAndAlignments
(
    const List<Point>& storePts
)
{
    timeCheck("Start of storeSizesAndAlignments");

    Info << nl << "Store size and alignment" << endl;

    sizeAndAlignmentLocations_.setSize(storePts.size());

    storedSizes_.setSize(sizeAndAlignmentLocations_.size());

    storedAlignments_.setSize(sizeAndAlignmentLocations_.size());

    label i = 0;

    for
    (
        List<Point>::const_iterator pit = storePts.begin();
        pit != storePts.end();
        ++pit
    )
    {
        sizeAndAlignmentLocations_[i] = topoint(*pit);

        storedSizes_[i] = cellSizeControl().cellSize
        (
            sizeAndAlignmentLocations_[i]
        );

        storedAlignments_[i] = requiredAlignment(sizeAndAlignmentLocations_[i]);

        i++;
    }

    timeCheck("Sizes and alignments calculated, build tree");

    buildSizeAndAlignmentTree();

    timeCheck("Size and alignment tree built");
}


void Foam::conformalVoronoiMesh::updateSizesAndAlignments
(
    const List<Point>& storePts
)
{
    // This function is only used in serial, the background redistribution
    // triggers this when unbalance is detected in parallel.

    if
    (
        !Pstream::parRun()
     && runTime_.run()
     && runTime_.timeIndex()
      % cvMeshControls().sizeAndAlignmentRebuildFrequency() == 0
    )
    {
        storeSizesAndAlignments(storePts);

        timeCheck("Updated sizes and alignments");
    }
}


const Foam::indexedOctree<Foam::treeDataPoint>&
Foam::conformalVoronoiMesh::sizeAndAlignmentTree() const
{
    if (sizeAndAlignmentTreePtr_.empty())
    {
        buildSizeAndAlignmentTree();
    }

    return sizeAndAlignmentTreePtr_();
}


void Foam::conformalVoronoiMesh::setVertexSizeAndAlignment()
{
    Info<< nl << "Looking up target cell alignment and size" << endl;

    const indexedOctree<treeDataPoint>& tree = sizeAndAlignmentTree();

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if
        (
            vit->internalOrBoundaryPoint()
         || vit->referredInternalOrBoundaryPoint()
        )
        {
            Foam::point pt(topoint(vit->point()));

            pointIndexHit info = tree.findNearest(pt, sqr(GREAT));

            if (info.hit())
            {
                vit->alignment() = storedAlignments_[info.index()];

                vit->targetCellSize() = storedSizes_[info.index()];
            }
            else
            {
                WarningIn
                (
                    "void "
                    "Foam::conformalVoronoiMesh::setVertexSizeAndAlignment()"
                )
                    << "Point " << pt << " did not find a nearest point "
                    << " for alignment and size lookup." << endl;

                vit->alignment() = requiredAlignment(pt);

                vit->targetCellSize() = cellSizeControl().cellSize(pt);
            }
        }
    }

    // Info<< nl << "Calculating target cell alignment and size" << endl;

    // for
    // (
    //     Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
    //     vit != finite_vertices_end();
    //     vit++
    // )
    // {
    //     if (vit->internalOrBoundaryPoint())
    //     {
    //         point pt(topoint(vit->point()));

    //         vit->alignment() = requiredAlignment(pt);

    //         vit->targetCellSize() = targetCellSize(pt);
    //     }
    // }
}


Foam::face Foam::conformalVoronoiMesh::buildDualFace
(
    const Delaunay::Finite_edges_iterator& eit
) const
{
    Cell_circulator ccStart = incident_cells(*eit);
    Cell_circulator cc1 = ccStart;
    Cell_circulator cc2 = cc1;

    // Advance the second circulator so that it always stays on the next
    // cell around the edge;
    cc2++;

    DynamicList<label> verticesOnFace;

    label nUniqueVertices = 0;

    do
    {
        if (cc1->farCell() || cc2->farCell())
        {
            Cell_handle c = eit->first;
            Vertex_handle vA = c->vertex(eit->second);
            Vertex_handle vB = c->vertex(eit->third);

            drawDelaunayCell(Pout, cc1);
            drawDelaunayCell(Pout, cc2);

            FatalErrorIn("Foam::conformalVoronoiMesh::buildDualFace")
                << "Dual face uses circumcenter defined by a "
                << "Delaunay tetrahedron with no internal "
                << "or boundary points.  Defining Delaunay edge ends: "
                << topoint(vA->point()) << " "
                << topoint(vB->point()) << nl
                << exit(FatalError);
        }

        label cc1I = cc1->cellIndex();

        label cc2I = cc2->cellIndex();

        if (cc1I != cc2I)
        {
            if (findIndex(verticesOnFace, cc1I) == -1)
            {
                nUniqueVertices++;
            }

            verticesOnFace.append(cc1I);
        }

        cc1++;

        cc2++;

    } while (cc1 != ccStart);

    if (verticesOnFace.size() >= 3 && nUniqueVertices < 3)
    {
        // There are not enough unique vertices on this face to
        // justify its size, it may have a form like:

        // Vertices:
        // A                                  B
        // A                                  B

        // Face:
        // ABAB

        // Setting the size to be below 3, so that it will not be
        // created

        verticesOnFace.setSize(nUniqueVertices);
    }

    return face(verticesOnFace);
}


Foam::label Foam::conformalVoronoiMesh::maxFilterCount
(
    const Delaunay::Finite_edges_iterator& eit
) const
{
    Cell_circulator ccStart = incident_cells(*eit);
    Cell_circulator cc = ccStart;

    label maxFC = 0;

    do
    {
        if (cc->farCell())
        {
            Cell_handle c = eit->first;
            Vertex_handle vA = c->vertex(eit->second);
            Vertex_handle vB = c->vertex(eit->third);

            FatalErrorIn("Foam::conformalVoronoiMesh::buildDualFace")
                << "Dual face uses circumcenter defined by a "
                << "Delaunay tetrahedron with no internal "
                << "or boundary points.  Defining Delaunay edge ends: "
                << topoint(vA->point()) << " "
                << topoint(vB->point()) << nl
                << exit(FatalError);
        }

        if (cc->filterCount() > maxFC)
        {
            maxFC = cc->filterCount();
        }

        cc++;

    } while (cc != ccStart);

    return maxFC;
}


bool Foam::conformalVoronoiMesh::ownerAndNeighbour
(
    Vertex_handle vA,
    Vertex_handle vB,
    label& owner,
    label& neighbour
) const
{
    bool reverse = false;

    owner = -1;
    neighbour = -1;

    label dualCellIndexA = vA->index();

    if (!vA->internalOrBoundaryPoint())
    {
        dualCellIndexA = -1;
    }

    label dualCellIndexB = vB->index();

    if (!vB->internalOrBoundaryPoint())
    {
        dualCellIndexB = -1;
    }

    if (dualCellIndexA == -1 && dualCellIndexB == -1)
    {
        FatalErrorIn
        (
            "bool Foam::conformalVoronoiMesh::ownerAndNeighbour"
            "("
                "Vertex_handle vA,"
                "Vertex_handle vB,"
                "label& owner,"
                "label& neighbour"
            ") const"
        )
            << "Attempting to create a face joining "
            << "two unindexed dual cells "
            << exit(FatalError);
    }
    else if (dualCellIndexA == -1 || dualCellIndexB == -1)
    {
        // boundary face, find which is the owner

        if (dualCellIndexA == -1)
        {
            owner = dualCellIndexB;

            reverse = true;
        }
        else
        {
            owner = dualCellIndexA;
        }
    }
    else
    {
        // internal face, find the lower cell to be the owner

        if (dualCellIndexB > dualCellIndexA)
        {
            owner = dualCellIndexA;
            neighbour = dualCellIndexB;
        }
        else
        {
            owner = dualCellIndexB;
            neighbour = dualCellIndexA;

            // reverse face order to correctly orientate normal
            reverse = true;
        }
    }

    return reverse;
}


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::conformalVoronoiMesh::conformalVoronoiMesh
(
    const Time& runTime,
    const dictionary& cvMeshDict
)
:
    Delaunay(),
    runTime_(runTime),
    rndGen_(64293*Pstream::myProcNo()),
    cvMeshControls_(cvMeshDict),
    allGeometry_
    (
        IOobject
        (
            "cvSearchableSurfaces",
            runTime_.constant(),
            "triSurface",
            runTime_,
            IOobject::MUST_READ,
            IOobject::NO_WRITE
        ),
        cvMeshDict.subDict("geometry")
    ),
    geometryToConformTo_
    (
        runTime_,
        rndGen_,
        allGeometry_,
        cvMeshDict.subDict("surfaceConformation")
    ),
    cellSizeControl_
    (
        allGeometry_,
        cvMeshDict.subDict("motionControl")
    ),
    startOfInternalPoints_(0),
    limitBounds_(),
    featureVertices_(),
    featurePointLocations_(),
    featurePointTreePtr_(),
    edgeLocationTreePtr_(),
    surfacePtLocationTreePtr_(),
    sizeAndAlignmentLocations_(),
    storedSizes_(),
    storedAlignments_(),
    sizeAndAlignmentTreePtr_(),
    surfaceConformationVertices_(),
    initialPointsMethod_
    (
        initialPointsMethod::New
        (
            cvMeshDict.subDict("initialPoints"),
            *this
        )
    ),
    relaxationModel_
    (
        relaxationModel::New
        (
            cvMeshDict.subDict("motionControl"),
            runTime_
        )
    ),
    faceAreaWeightModel_
    (
        faceAreaWeightModel::New
        (
            cvMeshDict.subDict("motionControl")
        )
    ),
    decomposition_()
{
    if (Pstream::parRun())
    {
        decomposition_.reset
        (
            new backgroundMeshDecomposition
            (
                cvMeshDict.subDict("backgroundMeshDecomposition"),
                *this
            )
        );
    }

    if (cvMeshControls().objOutput())
    {
        geometryToConformTo_.writeFeatureObj("cvMesh");
    }

    insertBoundingPoints();

    insertFeaturePoints();

    startOfInternalPoints_ = number_of_vertices();

    insertInitialPoints();

    // Improve the guess that the backgroundMeshDecomposition makes with the
    // initial positions.  Use before building the surface conformation to
    // better balance the surface conformation load.
    distributeBackground();

    buildSurfaceConformation(rmCoarse);

    // The introduction of the surface conformation may have distorted the
    // balance of vertices, distribute if necessary.
    if (distributeBackground())
    {
        // distributeBackground has destroyed all referred vertices, so the
        // parallel interface needs to be rebuilt.
        buildParallelInterface("rebuild");
    }

    // Do not store the surface conformation until after it has been
    // (potentially) redistributed.
    storeSurfaceConformation();

    // Use storeSizesAndAlignments with no feed points because all background
    // points may have been distributed.  It is a requirement that none of the
    // preceding functions requires look up of sizes or alignments from the
    // Delaunay vertices, i.e. setVertexSizeAndAlignment cannot be called
    // before this point.
    storeSizesAndAlignments();

    // Report any Delaunay vertices that do not think that they are in the
    // domain the processor they are on.
    // reportProcessorOccupancy();

    if (cvMeshControls().objOutput())
    {
        writePoints("allInitialPoints.obj", false);
    }
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

Foam::conformalVoronoiMesh::~conformalVoronoiMesh()
{}


// * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * * //

void Foam::conformalVoronoiMesh::move()
{
    timeCheck("Start of move");

    scalar relaxation = relaxationModel_->relaxation();

    Info<< nl << "Relaxation = " << relaxation << endl;

    pointField dualVertices(number_of_cells());

    label dualVertI = 0;

    // Find the dual point of each tetrahedron and assign it an index.
    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        cit->cellIndex() = Cb::ctFar;

        if (cit->anyInternalOrBoundaryDualVertex())
        {
            cit->cellIndex() = dualVertI;

            dualVertices[dualVertI] = topoint(dual(cit));

            dualVertI++;
        }
    }

    dualVertices.setSize(dualVertI);

    setVertexSizeAndAlignment();

    timeCheck("Determined sizes and alignments");

    Info<< nl << "Determining vertex displacements" << endl;

    vectorField cartesianDirections(3);

    cartesianDirections[0] = vector(0,0,1);
    cartesianDirections[1] = vector(0,1,0);
    cartesianDirections[2] = vector(1,0,0);

    vectorField displacementAccumulator
    (
        number_of_vertices(),
        vector::zero
    );

    PackedBoolList pointToBeRetained
    (
        number_of_vertices(),
        true
    );

    DynamicList<Point> pointsToInsert(number_of_vertices());

    for
    (
        Delaunay::Finite_edges_iterator eit = finite_edges_begin();
        eit != finite_edges_end();
        ++eit
    )
    {
        Cell_handle c = eit->first;
        Vertex_handle vA = c->vertex(eit->second);
        Vertex_handle vB = c->vertex(eit->third);

        if (!vA->internalOrBoundaryPoint() && !vB->internalOrBoundaryPoint())
        {
            // At least one vertex has to be a real internalOrBoundaryPoint
            continue;
        }

        if
        (
            vA->anyInternalOrBoundaryPoint()
         && vB->anyInternalOrBoundaryPoint()
        )
        {
            face dualFace = buildDualFace(eit);

            Foam::point dVA = topoint(vA->point());
            Foam::point dVB = topoint(vB->point());

            Field<vector> alignmentDirsA(vA->alignment() & cartesianDirections);
            Field<vector> alignmentDirsB(vB->alignment() & cartesianDirections);

            Field<vector> alignmentDirs(3);

            forAll(alignmentDirsA, aA)
            {
                const vector& a = alignmentDirsA[aA];

                scalar maxDotProduct = 0.0;

                forAll(alignmentDirsB, aB)
                {
                    const vector& b = alignmentDirsB[aB];

                    const scalar dotProduct = a & b;

                    if (mag(dotProduct) > maxDotProduct)
                    {
                        maxDotProduct = mag(dotProduct);

                        alignmentDirs[aA] = a + sign(dotProduct)*b;

                        alignmentDirs[aA] /= mag(alignmentDirs[aA]);
                    }
                }
            }

            vector rAB = dVA - dVB;

            scalar rABMag = mag(rAB);

            if (rABMag < SMALL)
            {
                // Removal of close points

                if (vA->internalPoint() && vB->internalPoint())
                {
                    // Only insert a point at the midpoint of
                    // the short edge if neither attached
                    // point has already been identified to be
                    // removed.

                    if
                    (
                        pointToBeRetained[vA->index()] == true
                     && pointToBeRetained[vB->index()] == true
                    )
                    {
                        pointsToInsert.append
                        (
                            toPoint(0.5*(dVA + dVB))
                        );
                    }
                }

                if (vA->internalPoint())
                {
                    pointToBeRetained[vA->index()] = false;
                }

                if (vB->internalPoint())
                {
                    pointToBeRetained[vB->index()] = false;
                }

                // Do not consider this Delaunay edge any further

                continue;
            }

            forAll(alignmentDirs, aD)
            {
                vector& alignmentDir = alignmentDirs[aD];

                if ((rAB & alignmentDir) < 0)
                {
                    // swap the direction of the alignment so that has the
                    // same sense as rAB
                    alignmentDir *= -1;
                }

                const scalar alignmentDotProd = ((rAB/rABMag) & alignmentDir);

                if
                (
                    alignmentDotProd
                  > cvMeshControls().cosAlignmentAcceptanceAngle()
                )
                {
                    const scalar targetCellSize = averageCellSize(vA, vB);

                    const scalar targetFaceArea = sqr(targetCellSize);

                    alignmentDir *= 0.5*targetCellSize;

                    // Vector to move end points around middle of vector
                    // to align edge (i.e. dual face normal) with alignment
                    // directions.
                    vector delta = alignmentDir - 0.5*rAB;

                    const scalar faceArea = dualFace.mag(dualVertices);

                    delta *= faceAreaWeightModel_->faceAreaWeight
                    (
                        faceArea/targetFaceArea
                    );

                    if
                    (
                        vA->internalPoint()
                     && vB->internalPoint()
                     && rABMag
                      > cvMeshControls().insertionDistCoeff()*targetCellSize
                     && faceArea
                      > cvMeshControls().faceAreaRatioCoeff()*targetFaceArea
                     && alignmentDotProd
                      > cvMeshControls().cosInsertionAcceptanceAngle()
                    )
                    {
                        // Point insertion

                        if
                        (
                            !geometryToConformTo_.findSurfaceAnyIntersection
                            (
                                dVA,
                                dVB
                            )
                        )
                        {
                            // Prevent insertions spanning surfaces
                            pointsToInsert.append
                            (
                                toPoint(0.5*(dVA + dVB))
                            );

                        }
                    }
                    else if
                    (
                        (vA->internalPoint() || vB->internalPoint())
                     && rABMag
                      < cvMeshControls().removalDistCoeff()*targetCellSize
                    )
                    {
                        // Point removal

                        if (vA->internalPoint() && vB->internalPoint())
                        {
                            // Only insert a point at the midpoint of
                            // the short edge if neither attached
                            // point has already been identified to be
                            // removed.
                            if
                            (
                                pointToBeRetained[vA->index()] == true
                             && pointToBeRetained[vB->index()] == true
                            )
                            {
                                pointsToInsert.append
                                (
                                    toPoint(0.5*(dVA + dVB))
                                );
                            }
                        }

                        if (vA->internalPoint())
                        {
                            pointToBeRetained[vA->index()] = false;
                        }

                        if (vB->internalPoint())
                        {
                            pointToBeRetained[vB->index()] = false;
                        }
                    }
                    else
                    {
                        if (vA->internalPoint())
                        {
                            displacementAccumulator[vA->index()] += delta;
                        }

                        if (vB->internalPoint())
                        {
                            displacementAccumulator[vB->index()] += -delta;
                        }
                    }
                }
            }
        }
    }

    // Limit displacements that pierce, or get too close to the surface
    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->internalPoint())
        {
            limitDisplacement
            (
                vit,
                displacementAccumulator[vit->index()]
            );
        }
    }

    vector totalDisp = gSum(displacementAccumulator);
    scalar totalDist = gSum(mag(displacementAccumulator));

    // Relax the calculated displacement
    displacementAccumulator *= relaxation;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->internalPoint())
        {
            if (pointToBeRetained[vit->index()] == true)
            {
                // Convert vit->point() to FOAM vector (double) to do addition,
                // avoids memory increase because a record of the constructions
                // would be kept otherwise.
                // See cgal-discuss@lists-sop.inria.fr:
                // "Memory issue with openSUSE 11.3, exact kernel, adding
                //  points/vectors"
                // 14/1/2011.
                // Only necessary if using an exact constructions kernel
                // (extended precision)

                pointsToInsert.append
                (
                    toPoint
                    (
                        topoint(vit->point())
                      + displacementAccumulator[vit->index()]
                    )
                );
            }
        }
    }

    pointsToInsert.shrink();

    // Save displacements to file.
    if (cvMeshControls().objOutput() && runTime_.outputTime())
    {
        Pout<< "Writing point displacement vectors to file." << endl;
        OFstream str("displacements_" + runTime_.timeName() + ".obj");

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            ++vit
        )
        {
            if (vit->internalPoint())
            {
                if (pointToBeRetained[vit->index()] == true)
                {
                    meshTools::writeOBJ(str, topoint(vit->point()));

                    str << "vn "
                        << displacementAccumulator[vit->index()][0] << " "
                        << displacementAccumulator[vit->index()][1] << " "
                        << displacementAccumulator[vit->index()][2] << " "
                        << endl;
                }
            }
        }
    }

    // Remove the entire tessellation
    reset();

    if (cvMeshControls().objOutput() && runTime_.outputTime())
    {
        writePoints("featurePoints_" + runTime_.timeName() + ".obj", false);
    }

    timeCheck("Displacement calculated");

    Info<< nl << "Inserting displaced tessellation" << endl;

    insertPoints(pointsToInsert);

    if (cvMeshControls().objOutput() && runTime_.outputTime())
    {
        writePoints("points_" + runTime_.timeName() + ".obj", false);
    }

    timeCheck("Internal points inserted");

    conformToSurface();

    if (cvMeshControls().objOutput() && runTime_.outputTime())
    {
        writeBoundaryPoints("boundaryPoints_" + runTime_.timeName() + ".obj");
    }

    timeCheck("After conformToSurface");

    // Write the intermediate mesh, do not filter the dual faces.
    if (runTime_.outputTime())
    {
        writeMesh(runTime_.timeName(), false);
    }

    updateSizesAndAlignments(pointsToInsert);

    Info<< nl
        << "Total displacement = " << totalDisp << nl
        << "Total distance = " << totalDist << nl
        << endl;
}


bool Foam::conformalVoronoiMesh::positionOnThisProc
(
    const Foam::point& pt
) const
{
    if (Pstream::parRun())
    {
        return decomposition_().positionOnThisProcessor(pt);
    }

    return true;
}


Foam::boolList Foam::conformalVoronoiMesh::positionOnThisProc
(
    const Foam::List<Foam::point>& pts
) const
{
    if (Pstream::parRun())
    {
        return decomposition_().positionOnThisProcessor(pts);
    }

    return boolList(pts.size(), true);
}


Foam::labelList Foam::conformalVoronoiMesh::positionProc
(
    const Foam::List<Foam::point>& pts
) const
{
    if (!Pstream::parRun())
    {
        return labelList(pts.size(), -1);
    }

    return decomposition_().processorPosition(pts);
}


Foam::List<Foam::List<Foam::pointIndexHit> >
Foam::conformalVoronoiMesh::intersectsProc
(
    const List<Foam::point>& starts,
    const List<Foam::point>& ends
) const
{
    if (!Pstream::parRun())
    {
        return List<List<pointIndexHit> >(starts.size());
    }

    return decomposition_().intersectsProcessors(starts, ends, false);
}


Foam::labelListList Foam::conformalVoronoiMesh::overlapsProc
(
    const List<Foam::point>& centres,
    const List<scalar>& radiusSqrs
) const
{
    if (!Pstream::parRun())
    {
        return labelListList(centres.size(), labelList(0));
    }

    return decomposition_().overlapsProcessors(centres, radiusSqrs, false);
}


// ************************************************************************* //
