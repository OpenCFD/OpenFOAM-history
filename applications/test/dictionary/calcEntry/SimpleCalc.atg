/*-------------------------------------------------------------------------
 compile with:
 Coco \
    -frames $WM_THIRD_PARTY_DIR/coco-r \
    -prefix calcEntry \
    -namespace Foam::functionEntries::calcEntryInternal \
    SimpleCalc.atg
-------------------------------------------------------------------------*/

#include "dictionary.H"
#include "scalar.H"
#include "error.H"
#include "wchar.H"


COMPILER SimpleCalc
    // Simple four function calculator for OpenFOAM dictionaries

    //! with debug
    static const int debug = 0;

    //! The parent dictionary
    mutable dictionary* dict_;

    //! The calculation result
    scalar val;

    //! token -> scalar
    scalar getScalar() const
    {
        return coco_string_toDouble(t->val);
    }

    //! token -> string
    std::string getString() const
    {
        char* str = coco_string_create_char(t->val);
        std::string s(str);
        coco_string_delete(str);
        return s;
    }


    //! attach a dictionary
    void dict(const dictionary& dict) const
    {
        dict_ = const_cast<dictionary*>(&dict);
    }


    //! lookup dictionary entry
    scalar getDictLookup() const
    {
        scalar dictValue = 0;

        if (!dict_)
        {
            FatalErrorIn
            (
                "SimpleCalc::getDictEntry() const"
            )   << "No dictionary attached!"
                << exit(FatalError);

            return 0;
        }

        char* chars = coco_string_create_char
        (
            t->val,
            1,
            (coco_string_length(t->val) - 1)
        );
        word keyword(chars);
        coco_string_delete(chars);

        if (debug)
        {
            Info<<"lookup: " << keyword << nl;
        }

        entry* entryPtr = dict_->lookupEntryPtr(keyword, true, false);
        if (entryPtr && !entryPtr->isDict())
        {
            entryPtr->stream() >> dictValue;
        }
        else
        {
            FatalErrorIn
            (
                "SimpleCalc::getDictEntry() const"
            )   << "keyword " << keyword << " is undefined in dictionary "
                << exit(FatalError);
        }


        return dictValue;
    }

    scalar Result() const
    {
        return val;
    }


// * * * * * * * * * * * * * * *  CHARACTERS * * * * * * * * * * * * * * * * //

CHARACTERS
    letter    = 'A'..'Z' + 'a'..'z'.
    qualifier = '_' + ':'.
    dollar    = '$'.
    digit     = "0123456789".
    sign      = '+' + '-'.
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    printable = '\u0020' .. '\u007e'.


// * * * * * * * * * * * * * * * *  TOKENS * * * * * * * * * * * * * * * * * //

TOKENS

// identifier
ident  =
    letter { letter | digit | qualifier }.

// string
string =
    '"' { stringCh | '\\' printable } '"'.

// dictionary lookup identifier
// starts with '$' and otherwise limited to a normal indentifier
variable  =
    dollar letter { letter | digit | qualifier }.

// floating point and integer numbers
number  =
    [sign] ('.' digit { digit } ) | ( digit { digit } [ '.' { digit } ])
    [ ('E' | 'e') [sign] digit { digit } ].


// * * * * * * * * * * *  PRAGMAS / COMMENTS / IGNORE  * * * * * * * * * * * //

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

// ignore unprintables
IGNORE  ANY - printable


// * * * * * * * * * * * * * * *  PRODUCTIONS  * * * * * * * * * * * * * * * //

PRODUCTIONS

SimpleCalc                      (. val = 0;
                                   if (debug){Info<<"start val"<< nl;}
                                 .)
=
  ( '{' Expr<val> '}' | Expr<val> )
  EOF
.


/*---------------------------------------------------------------------------*/

Expr<scalar& val>               (. scalar val2 = 0;
                                   if (debug) {Info<<"Expr:"<< val<< nl;}
                                 .)
=
  Term<val>
  {
      "+" Term<val2>            (. if (debug) {Info<<"+Term:"<<val2 <<nl;}
                                   val += val2;
                                   if (debug) {Info<<"="<< val << nl;}
                                 .)
    | "-" Term<val2>            (. if (debug) {Info<<"-Term:"<<val2 <<nl;}
                                   val -= val2;
                                   if (debug) {Info<<"="<< val << nl;}
                                 .)
  }
.


/*---------------------------------------------------------------------------*/

Term<scalar& val>               (. scalar val2 = 0;
                                   if (debug) {Info<<"Term:"<< val<< nl;}
                                 .)
=
  Factor<val>
  {
     "*" Factor<val2>           (. if (debug) {Info<<"*Factor:"<<val2 << nl;}
                                   val *= val2;
                                   if (debug) {Info<<"="<< val << nl; }
                                 .)
  |  "/" Factor<val2>           (. if (debug) {Info<<"/Factor:"<<val2 << nl;}
                                   val /= val2;
                                   if (debug) {Info<<"="<< val << nl; }
                                 .)
  }
.


/*---------------------------------------------------------------------------*/
Factor<scalar& val>
=
    variable                    (. val = getDictLookup();
                                   if (debug) {Info<<"lookup:"<<val<<nl;}
                                 .)
  | number                      (. val = getScalar();
                                   if (debug) {Info<<"got num:"<<val<<nl;}
                                 .)
  | '-' '(' Expr<val> ')'       (. val = -val;
                                   if (debug) {Info<<"inv:"<<val<<nl;}
                                 .)
  | '(' Expr<val> ')'           (. if (debug){Info<<"got Expr:"<<val<<nl;} .)
.


/*---------------------------------------------------------------------------*/

END SimpleCalc.

// ************************************************************************* //
