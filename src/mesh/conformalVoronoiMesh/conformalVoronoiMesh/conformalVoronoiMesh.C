/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2009-2011 OpenCFD Ltd.
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "conformalVoronoiMesh.H"
#include "initialPointsMethod.H"
#include "relaxationModel.H"
#include "faceAreaWeightModel.H"
#include "backgroundMeshDecomposition.H"
#include "meshSearch.H"

// * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * * //

Foam::tensor Foam::conformalVoronoiMesh::requiredAlignment
(
    const Foam::point& pt
) const
{
    pointIndexHit surfHit;
    label hitSurface;

    geometryToConformTo_.findSurfaceNearest
    (
        pt,
        sqr(GREAT),
        surfHit,
        hitSurface
    );

    if (!surfHit.hit())
    {
        FatalErrorIn
        (
            "Foam::tensor Foam::conformalVoronoiMesh::requiredAlignment"
        )
            << "findSurfaceNearest did not find a hit across the surfaces."
            << exit(FatalError) << endl;
    }

    // Primary alignment

    vectorField norm(1);

    allGeometry_[hitSurface].getNormal
    (
        List<pointIndexHit>(1, surfHit),
        norm
    );

    vector np = norm[0];

    // Generate equally spaced 'spokes' in a circle normal to the
    // direction from the vertex to the closest point on the surface
    // and look for a secondary intersection.

    vector d = surfHit.hitPoint() - pt;

    tensor Rp = rotationTensor(vector(0,0,1), np);

    label s = cvMeshControls().alignmentSearchSpokes();

    scalar closestSpokeHitDistance = GREAT;

    pointIndexHit closestSpokeHit;

    label closestSpokeSurface = -1;

    scalar spanMag = geometryToConformTo_.globalBounds().mag();

    for(label i = 0; i < s; i++)
    {
        vector spoke
        (
            Foam::cos(i*constant::mathematical::twoPi/s),
            Foam::sin(i*constant::mathematical::twoPi/s),
            0
        );

        spoke *= spanMag;

        spoke = Rp & spoke;

        pointIndexHit spokeHit;

        label spokeSurface = -1;

        // internal spoke

        geometryToConformTo_.findSurfaceNearestIntersection
        (
            pt,
            pt + spoke,
            spokeHit,
            spokeSurface
        );

        if (spokeHit.hit())
        {
            scalar spokeHitDistance = mag
            (
                spokeHit.hitPoint() - pt
            );

            if (spokeHitDistance < closestSpokeHitDistance)
            {
                closestSpokeHit = spokeHit;
                closestSpokeSurface = spokeSurface;
                closestSpokeHitDistance = spokeHitDistance;
            }
        }

        //external spoke

        Foam::point mirrorPt = pt + 2*d;

        geometryToConformTo_.findSurfaceNearestIntersection
        (
            mirrorPt,
            mirrorPt + spoke,
            spokeHit,
            spokeSurface
        );

        if (spokeHit.hit())
        {
            scalar spokeHitDistance = mag
            (
                spokeHit.hitPoint() - mirrorPt
            );

            if (spokeHitDistance < closestSpokeHitDistance)
            {
                closestSpokeHit = spokeHit;
                closestSpokeSurface = spokeSurface;
                closestSpokeHitDistance = spokeHitDistance;
            }
        }
    }

    if (closestSpokeSurface == -1)
    {
        FatalErrorIn("conformalVoronoiMesh::requiredAlignment")
            << "No secondary surface hit found in spoke search."
            << nl << exit(FatalError);
    }

    // Auxiliary alignment generated by spoke intersection normal.

    allGeometry_[closestSpokeSurface].getNormal
    (
        List<pointIndexHit>(1, closestSpokeHit),
        norm
    );

    const vector& na = norm[0];

    // Secondary alignment
    vector ns = np ^ na;

    if (mag(ns) <  SMALL)
    {
        FatalErrorIn("conformalVoronoiMesh::requiredAlignment")
            << "Parallel normals detected in spoke search." << nl
            << "point: " << pt << nl
            << "closest surface point: " << surfHit.hitPoint() << nl
            << "closest spoke hit: " << closestSpokeHit.hitPoint() << nl
            << "np: " << surfHit.hitPoint() + np << nl
            << "ns: " << closestSpokeHit.hitPoint() + na << nl
            << exit(FatalError);
    }

    ns /= mag(ns);

    tensor Rs = rotationTensor((Rp & vector(0,1,0)), ns);

    return (Rs & Rp);
}


void Foam::conformalVoronoiMesh::insertPoints
(
    std::list<Point>& points,
    bool distribute
)
{
    label preInsertionSize(number_of_vertices());

    label nPoints = points.size();

    if (Pstream::parRun())
    {
        reduce(nPoints, sumOp<label>());
    }

    Info<< "    " << nPoints << " points to insert..." << endl;

    if (Pstream::parRun() && distribute)
    {
        label preDistributionSize(points.size());

        DynamicList<Foam::point> transferPoints;

        for
        (
            std::list<Point>::iterator pit=points.begin();
            pit != points.end();
            // No action
        )
        {
            Foam::point p(topoint(*pit));

            if (!positionOnThisProc(p))
            {
                transferPoints.append(p);

                pit = points.erase(pit);
            }
            else
            {
                ++pit;
            }
        }

        // Send the points that are not on this processor to the appropriate
        // place
        Foam::autoPtr<Foam::mapDistribute> map
        (
            decomposition_().distributePoints(transferPoints)
        );

        forAll(transferPoints, tPI)
        {
            points.push_back(toPoint(transferPoints[tPI]));
        }

        label sizeChange = preDistributionSize - label(points.size());

        if (mag(sizeChange) > 0)
        {
            Pout<< "    distribution points size change " << sizeChange
                << endl;
        }

        nPoints = points.size();

        reduce(nPoints, sumOp<label>());

        Info<< "    " << nPoints
            << " points to insert after distribution..." << endl;
    }

    label nVert = number_of_vertices();

    // using the range insert (faster than inserting points one by one)
    insert(points.begin(), points.end());

    // Info<< "USING INDIVIDUAL INSERTION TO DETECT FAILURE" << endl;
    // for
    // (
    //     std::list<Point>::iterator pit=points.begin();
    //     pit != points.end();
    //     ++pit
    // )
    // {
    //     insertPoint(topoint(*pit), Vb::ptInternalPoint);
    // }

    label nInserted(number_of_vertices() - preInsertionSize);

    if (Pstream::parRun())
    {
        reduce(nInserted, sumOp<label>());
    }

    Info<< "    " << nInserted << " points inserted" << endl;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->uninitialised())
        {
            vit->index() = nVert++;
        }
    }
}


void Foam::conformalVoronoiMesh::insertPoints
(
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types,
    bool distribute
)
{
    // The pts, indices and types lists must be intact and up-to-date at the
    // end of this function as they may also be used by other functions
    // subsequently.

    if (Pstream::parRun() && distribute)
    {
        // The link between vertices that form the boundary via pairs cannot be
        // strict because both points may end up on different processors.  The
        // only important thing is that each vertex knows its own role.
        // Therefore, index and type are set to 0 or 1, then on the destination
        // processor add back the new index to both.

        // Each of points generated in this process are pair points, so there
        // is no risk of underflowing "type".

        // Pout<< "Points before "
        //     << pts.size() << " " << indices.size() << " " << types.size()
        //     << endl;

        // Distribute points to their appropriate processor
        autoPtr<mapDistribute> map
        (
            decomposition_().distributePoints(pts)
        );

        map().distribute(indices);
        map().distribute(types);

        // Pout<< "Points after "
        //     << pts.size() << " " << indices.size() << " " << types.size()
        //     << endl;

        // Info<< returnReduce(pts.size(), sumOp<label>())
        //     << " points in total" << endl;
    }

    // Using index is actually pointless, it is always zero.  Keep for clarity
    // of code.

    forAll(pts, pI)
    {
        // creation of points and indices is done assuming that it will be
        // relative to the instantaneous number_of_vertices() at insertion.

        label type = types[pI];

        if (type > Vb::ptFarPoint)
        {
            // This is a member of a point pair, don't use the type directly
            type += number_of_vertices();
        }

        insertPoint
        (
            pts[pI],
            indices[pI] + number_of_vertices(),
            type
        );
    }
}


void Foam::conformalVoronoiMesh::insertSurfacePointPairs
(
    const List<pointIndexHit>& surfaceHits,
    const List<label>& hitSurfaces,
    const fileName fName
)
{
    if (surfaceHits.size() != hitSurfaces.size())
    {
        FatalErrorIn("Foam::conformalVoronoiMesh::insertPointPairs")
            << "surfaceHits and hitSurfaces are not the same size. Sizes "
            << surfaceHits.size() << ' '
            << hitSurfaces.size()
            << exit(FatalError);
    }

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    forAll(surfaceHits, i)
    {
        vectorField norm(1);

        allGeometry_[hitSurfaces[i]].getNormal
        (
            List<pointIndexHit>(1, surfaceHits[i]),
            norm
        );

        const vector& normal = norm[0];

        const Foam::point& surfacePt(surfaceHits[i].hitPoint());

        createPointPair
        (
            pointPairDistance(surfacePt),
            surfacePt,
            normal,
            pts,
            indices,
            types
        );
    }

    insertPoints(pts, indices, types, true);

    if(cvMeshControls().objOutput() && fName != fileName::null)
    {
        writePoints(fName, pts);
    }
}


void Foam::conformalVoronoiMesh::insertEdgePointGroups
(
    const List<pointIndexHit>& edgeHits,
    const labelList& featuresHit,
    const fileName fName
)
{
    if (edgeHits.size() != featuresHit.size())
    {
        FatalErrorIn("Foam::conformalVoronoiMesh::insertEdgePointGroups")
            << "edgeHits and featuresHit are not the same size. Sizes "
            << edgeHits.size() << ' '
            << featuresHit.size()
            << exit(FatalError);
    }

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    forAll(edgeHits, i)
    {
        const extendedFeatureEdgeMesh& feMesh
        (
            geometryToConformTo_.features()[featuresHit[i]]
        );

        createEdgePointGroup(feMesh, edgeHits[i], pts, indices, types);
    }

    insertPoints(pts, indices, types, true);

    if(cvMeshControls().objOutput() && fName != fileName::null)
    {
        writePoints(fName, pts);
    }
}


void Foam::conformalVoronoiMesh::createEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    label edgeI = edHit.index();

    extendedFeatureEdgeMesh::edgeStatus edStatus = feMesh.getEdgeStatus(edgeI);

    switch (edStatus)
    {
        case extendedFeatureEdgeMesh::EXTERNAL:
        {
            createExternalEdgePointGroup(feMesh, edHit, pts, indices, types);
            break;
        }
        case extendedFeatureEdgeMesh::INTERNAL:
        {
            createInternalEdgePointGroup(feMesh, edHit, pts, indices, types);
            break;
        }
        case extendedFeatureEdgeMesh::FLAT:
        {
            createFlatEdgePointGroup(feMesh, edHit, pts, indices, types);
            break;
        }
        case extendedFeatureEdgeMesh::OPEN:
        {
            createOpenEdgePointGroup(feMesh, edHit, pts, indices, types);
            break;
        }
        case extendedFeatureEdgeMesh::MULTIPLE:
        {
            createMultipleEdgePointGroup(feMesh, edHit, pts, indices, types);
            break;
        }
        case extendedFeatureEdgeMesh::NONE:
        {
            break;
        }
    }
}


void Foam::conformalVoronoiMesh::createExternalEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    const Foam::point& edgePt = edHit.hitPoint();

    scalar ppDist = pointPairDistance(edgePt);

    const vectorField& feNormals = feMesh.normals();
    const labelList& edNormalIs = feMesh.edgeNormals()[edHit.index()];

    // As this is an external edge, there are two normals by definition
    const vector& nA = feNormals[edNormalIs[0]];
    const vector& nB = feNormals[edNormalIs[1]];

    // Convex. So refPt will be inside domain and hence a master point
    Foam::point refPt = edgePt - ppDist*(nA + nB)/(1 + (nA & nB) + VSMALL);

    // Result when the points are eventually inserted.
    // Add number_of_vertices() at insertion of first vertex to all numbers:
    // pt           index type
    // refPt        0     1
    // reflectedA   1     0
    // reflectedB   2     0

    // Insert the master point pairing the the first slave

    pts.append(refPt);
    indices.append(0);
    types.append(1);

    // Insert the slave points by reflecting refPt in both faces.
    // with each slave refering to the master

    Foam::point reflectedA = refPt + 2*ppDist*nA;
    pts.append(reflectedA);
    indices.append(0);
    types.append(-1);

    Foam::point reflectedB = refPt + 2*ppDist*nB;
    pts.append(reflectedB);
    indices.append(0);
    types.append(-2);
}


void Foam::conformalVoronoiMesh::createInternalEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    const Foam::point& edgePt = edHit.hitPoint();

    scalar ppDist = pointPairDistance(edgePt);

    const vectorField& feNormals = feMesh.normals();
    const labelList& edNormalIs = feMesh.edgeNormals()[edHit.index()];

    // As this is an external edge, there are two normals by definition
    const vector& nA = feNormals[edNormalIs[0]];
    const vector& nB = feNormals[edNormalIs[1]];

    // Concave. master and reflected points inside the domain.
    Foam::point refPt = edgePt - ppDist*(nA + nB)/(1 + (nA & nB) + VSMALL);

    // Generate reflected master to be outside.
    Foam::point reflMasterPt = refPt + 2*(edgePt - refPt);

    // Reflect reflMasterPt in both faces.
    Foam::point reflectedA = reflMasterPt - 2*ppDist*nA;

    Foam::point reflectedB = reflMasterPt - 2*ppDist*nB;

    scalar totalAngle =
        radToDeg(constant::mathematical::pi + acos(mag(nA & nB)));

    // Number of quadrants the angle should be split into
    int nQuads = int(totalAngle/cvMeshControls().maxQuadAngle()) + 1;

    // The number of additional master points needed to obtain the
    // required number of quadrants.
    int nAddPoints = min(max(nQuads - 2, 0), 2);

    // index of reflMaster
    label reflectedMaster = 2 + nAddPoints;

    // Add number_of_vertices() at insertion of first vertex to all numbers:
    // Result for nAddPoints 1 when the points are eventually inserted
    // pt           index type
    // reflectedA   0     2
    // reflectedB   1     2
    // reflMasterPt 2     0

    // Result for nAddPoints 1 when the points are eventually inserted
    // pt           index type
    // reflectedA   0     3
    // reflectedB   1     3
    // refPt        2     3
    // reflMasterPt 3     0

    // Result for nAddPoints 2 when the points are eventually inserted
    // pt           index type
    // reflectedA   0     4
    // reflectedB   1     4
    // reflectedAa  2     4
    // reflectedBb  3     4
    // reflMasterPt 4     0

    // Master A is inside.
    pts.append(reflectedA);
    indices.append(0);
    types.append(reflectedMaster--);

    // Master B is inside.
    pts.append(reflectedB);
    indices.append(0);
    types.append(reflectedMaster--);

    if (nAddPoints == 1)
    {
        // One additinal point is the reflection of the slave point,
        // i.e. the original reference point
        pts.append(refPt);
        indices.append(0);
        types.append(reflectedMaster--);
    }
    else if (nAddPoints == 2)
    {
        Foam::point reflectedAa = refPt + ppDist*nB;
        pts.append(reflectedAa);
        indices.append(0);
        types.append(reflectedMaster--);

        Foam::point reflectedBb = refPt + ppDist*nA;
        pts.append(reflectedBb);
        indices.append(0);
        types.append(reflectedMaster--);
    }

    // Slave is outside.
    pts.append(reflMasterPt);
    indices.append(0);
    types.append(-(nAddPoints + 2));
}


void Foam::conformalVoronoiMesh::createFlatEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    const Foam::point& edgePt = edHit.hitPoint();

    scalar ppDist = pointPairDistance(edgePt);

    const vectorField& feNormals = feMesh.normals();
    const labelList& edNormalIs = feMesh.edgeNormals()[edHit.index()];

    // As this is a flat edge, there are two normals by definition
    const vector& nA = feNormals[edNormalIs[0]];
    const vector& nB = feNormals[edNormalIs[1]];

    // Average normal to remove any bias to one side, although as this
    // is a flat edge, the normals should be essentially the same
    vector n = 0.5*(nA + nB);

    // Direction along the surface to the control point, sense of edge
    // direction not important, as +s and -s can be used because this
    // is a flat edge
    vector s = 2.0*ppDist*(feMesh.edgeDirections()[edHit.index()] ^ n);

    createPointPair(ppDist, edgePt + s, n, pts, indices, types);
    createPointPair(ppDist, edgePt - s, n, pts, indices, types);
}


void Foam::conformalVoronoiMesh::createOpenEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    Info<< "NOT INSERTING OPEN EDGE POINT GROUP, NOT IMPLEMENTED" << endl;
}


void Foam::conformalVoronoiMesh::createMultipleEdgePointGroup
(
    const extendedFeatureEdgeMesh& feMesh,
    const pointIndexHit& edHit,
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    Info<< "NOT INSERTING MULTIPLE EDGE POINT GROUP, NOT IMPLEMENTED"
        << endl;
}


void Foam::conformalVoronoiMesh::insertFeaturePoints()
{
    Info<< nl << "Conforming to feature points" << endl;

    DynamicList<Foam::point> pts;
    DynamicList<label> indices;
    DynamicList<label> types;

    label preFeaturePointSize = number_of_vertices();

    createConvexFeaturePoints(pts, indices, types);

    createConcaveFeaturePoints(pts, indices, types);

    createMixedFeaturePoints(pts, indices, types);

    // Insert the created points, distributing to the appropriate processor
    insertPoints(pts, indices, types, true);

    if(cvMeshControls().objOutput())
    {
        writePoints("featureVertices.obj", pts);
    }

    label nFeatureVertices = number_of_vertices() - preFeaturePointSize;

    if (Pstream::parRun())
    {
        reduce(nFeatureVertices, sumOp<label>());
    }

    if (nFeatureVertices > 0)
    {
        Info<< "    Inserted " << nFeatureVertices
            << " feature vertices" << endl;
    }

    featureVertices_.clear();

    forAll(pts, pI)
    {
        featureVertices_.push_back
        (
            Vb(toPoint(pts[pI]), indices[pI], types[pI])
        );
    }

    constructFeaturePointLocations();
}


void Foam::conformalVoronoiMesh::createConvexFeaturePoints
(
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    const PtrList<extendedFeatureEdgeMesh>& feMeshes
    (
        geometryToConformTo_.features()
    );

    forAll(feMeshes, i)
    {
        const extendedFeatureEdgeMesh& feMesh(feMeshes[i]);

        for
        (
            label ptI = feMesh.convexStart();
            ptI < feMesh.concaveStart();
            ptI++
        )
        {
            const Foam::point& featPt = feMesh.points()[ptI];

            if (!positionOnThisProc(featPt))
            {
                continue;
            }

            vectorField featPtNormals = feMesh.featurePointNormals(ptI);

            vector cornerNormal = sum(featPtNormals);
            cornerNormal /= mag(cornerNormal);

            Foam::point internalPt =
                featPt - pointPairDistance(featPt)*cornerNormal;

            // Result when the points are eventually inserted (example n = 4)
            // Add number_of_vertices() at insertion of first vertex to all
            // numbers:
            // pt           index type
            // internalPt   0     1
            // externalPt0  1     0
            // externalPt1  2     0
            // externalPt2  3     0
            // externalPt3  4     0

            pts.append(internalPt);
            indices.append(0);
            types.append(1);

            label internalPtIndex = -1;

            forAll(featPtNormals, nI)
            {
                const vector& n = featPtNormals[nI];

                plane planeN = plane(featPt, n);

                Foam::point externalPt =
                    internalPt + 2.0 * planeN.distance(internalPt) * n;

                pts.append(externalPt);
                indices.append(0);
                types.append(internalPtIndex--);
            }
        }
    }
}


void Foam::conformalVoronoiMesh::createConcaveFeaturePoints
(
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    const PtrList<extendedFeatureEdgeMesh>& feMeshes
    (
        geometryToConformTo_.features()
    );

    forAll(feMeshes, i)
    {
        const extendedFeatureEdgeMesh& feMesh(feMeshes[i]);

        for
        (
            label ptI = feMesh.concaveStart();
            ptI < feMesh.mixedStart();
            ptI++
        )
        {
            const Foam::point& featPt = feMesh.points()[ptI];

            if (!positionOnThisProc(featPt))
            {
                continue;
            }

            vectorField featPtNormals = feMesh.featurePointNormals(ptI);

            vector cornerNormal = sum(featPtNormals);
            cornerNormal /= mag(cornerNormal);

            Foam::point externalPt =
                featPt + pointPairDistance(featPt)*cornerNormal;

            label externalPtIndex = featPtNormals.size();

            // Result when the points are eventually inserted (example n = 5)
            // Add number_of_vertices() at insertion of first vertex to all
            // numbers:
            // pt           index type
            // internalPt0  0     5
            // internalPt1  1     5
            // internalPt2  2     5
            // internalPt3  3     5
            // internalPt4  4     5
            // externalPt   5     4

            forAll(featPtNormals, nI)
            {
                const vector& n = featPtNormals[nI];

                plane planeN = plane(featPt, n);

                Foam::point internalPt =
                    externalPt - 2.0 * planeN.distance(externalPt) * n;

                pts.append(internalPt);
                indices.append(0);
                types.append(externalPtIndex--);
            }

            pts.append(externalPt);
            indices.append(0);
            types.append(-1);
        }
    }
}


void Foam::conformalVoronoiMesh::createMixedFeaturePoints
(
    DynamicList<Foam::point>& pts,
    DynamicList<label>& indices,
    DynamicList<label>& types
)
{
    Info<< "SKIP MIXED FEATURE POINTS" << endl;

    return;

    const PtrList<extendedFeatureEdgeMesh>& feMeshes
    (
        geometryToConformTo_.features()
    );

    forAll(feMeshes, i)
    {
        const extendedFeatureEdgeMesh& feMesh(feMeshes[i]);

        for
        (
            label ptI = feMesh.mixedStart();
            ptI < feMesh.nonFeatureStart();
            ptI++
        )
        {
            if
            (
                !createSpecialisedFeaturePoint(feMesh, ptI, pts, indices, types)
            )
            {
                // Specialisations available for some mixed feature points.  For
                // non-specialised feature points, inserting mixed internal and
                // external edge groups at feature point.

                const labelList& pEds(feMesh.pointEdges()[ptI]);

                // Skipping unsupported mixed feature point types

                bool skipEdge = false;

                forAll(pEds, e)
                {
                    label edgeI = pEds[e];

                    extendedFeatureEdgeMesh::edgeStatus edStatus =
                        feMesh.getEdgeStatus(edgeI);

                    if
                    (
                        edStatus == extendedFeatureEdgeMesh::OPEN
                     || edStatus == extendedFeatureEdgeMesh::MULTIPLE
                    )
                    {
                        Info<< "Edge type " << edStatus
                            << " found for mixed feature point " << ptI
                            << ". Not supported."
                            << endl;

                        skipEdge = true;
                    }
                }

                if(skipEdge)
                {
                    Info<< "Skipping point " << ptI << nl << endl;

                    continue;
                }

                const Foam::point& pt(feMesh.points()[ptI]);

                if (!positionOnThisProc(pt))
                {
                    continue;
                }

                scalar edgeGroupDistance = mixedFeaturePointDistance(pt);

                forAll(pEds, e)
                {
                    label edgeI = pEds[e];

                    Foam::point edgePt =
                        pt + edgeGroupDistance*feMesh.edgeDirection(edgeI, ptI);

                    pointIndexHit edgeHit(true, edgePt, edgeI);

                    createEdgePointGroup(feMesh, edgeHit, pts, indices, types);
                }
            }
        }
    }
}


void Foam::conformalVoronoiMesh::constructFeaturePointLocations()
{
    DynamicList<Foam::point> ftPtLocs;

    const PtrList<extendedFeatureEdgeMesh>& feMeshes
    (
        geometryToConformTo_.features()
    );

    forAll(feMeshes, i)
    {
        const extendedFeatureEdgeMesh& feMesh(feMeshes[i]);

        for
        (
            label ptI = feMesh.convexStart();
            ptI < feMesh.nonFeatureStart();
            ptI++
        )
        {
            ftPtLocs.append(feMesh.points()[ptI]);
        }
    }

    featurePointLocations_.transfer(ftPtLocs);
}


void Foam::conformalVoronoiMesh::reinsertFeaturePoints(bool distribute)
{
    Info<< nl << "Reinserting stored feature points" << endl;

    label preReinsertionSize(number_of_vertices());

    if (distribute)
    {
        DynamicList<Foam::point> pointsToInsert;
        DynamicList<label> indices;
        DynamicList<label> types;

        for
        (
            std::list<Vb>::iterator vit=featureVertices_.begin();
            vit != featureVertices_.end();
            ++vit
        )
        {
            pointsToInsert.append(topoint(vit->point()));
            indices.append(vit->index());
            types.append(vit->type());
        }

        // Insert distributed points
        insertPoints(pointsToInsert, indices, types, true);

        // Save points in new distribution
        featureVertices_.clear();

        forAll(pointsToInsert, pI)
        {
            featureVertices_.push_back
            (
                Vb(toPoint(pointsToInsert[pI]), indices[pI], types[pI])
            );
        }
    }
    else
    {
        for
        (
            std::list<Vb>::iterator vit=featureVertices_.begin();
            vit != featureVertices_.end();
            ++vit
        )
        {
            // Assuming that all of the reinsertions are pair points, and that
            // the index and type are relative, i.e. index 0 and type relative
            // to it.
            insertPoint
            (
                vit->point(),
                vit->index() + number_of_vertices(),
                vit->type() + number_of_vertices()
            );
        }
    }

    Info<< "    Reinserted "
        << returnReduce
        (
            label(number_of_vertices()) - preReinsertionSize,
            sumOp<label>()
        )
        << " vertices" << endl;
}


const Foam::indexedOctree<Foam::treeDataPoint>&
Foam::conformalVoronoiMesh::featurePointTree() const
{
    if (featurePointTreePtr_.empty())
    {
        treeBoundBox overallBb
        (
            geometryToConformTo_.globalBounds().extend(rndGen_, 1e-4)
        );

        overallBb.min() -= Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);
        overallBb.max() += Foam::point(ROOTVSMALL, ROOTVSMALL, ROOTVSMALL);

        featurePointTreePtr_.reset
        (
            new indexedOctree<treeDataPoint>
            (
                treeDataPoint(featurePointLocations_),
                overallBb,  // overall search domain
                10,         // max levels
                10.0,       // maximum ratio of cubes v.s. cells
                100.0       // max. duplicity; n/a since no bounding boxes.
            )
        );
    }

    return featurePointTreePtr_();
}


bool Foam::conformalVoronoiMesh::nearFeaturePt(const Foam::point& pt) const
{
    const indexedOctree<treeDataPoint>& tree = featurePointTree();

    scalar exclusionRangeSqr = featurePointExclusionDistanceSqr(pt);

    pointIndexHit info = tree.findNearest(pt, exclusionRangeSqr);

    return info.hit();
}


void Foam::conformalVoronoiMesh::reset()
{
    this->clear();

    insertBoundingPoints();
}


void Foam::conformalVoronoiMesh::insertBoundingPoints()
{
    pointField farPts = geometryToConformTo_.globalBounds().points();

    // Shift corners of bounds relative to origin
    farPts -= geometryToConformTo_.globalBounds().midpoint();

    // Scale the box up
    farPts *= 2.0;

    // Shift corners of bounds back to be relative to midpoint
    farPts += geometryToConformTo_.globalBounds().midpoint();

    forAll(farPts, fPI)
    {
        insertPoint(farPts[fPI], Vb::ptFarPoint);
    }
}


void Foam::conformalVoronoiMesh::insertInitialPoints()
{
    startOfInternalPoints_ = number_of_vertices();

    Info<< nl << "Inserting initial points" << endl;

    timeCheck("Before initial points call");

    std::list<Point> initPts = initialPointsMethod_->initialPoints();

    timeCheck("After initial points call");

    // Assume that the initial points method made the correct decision for
    // which processor each point should be on, so give distribute = false
    insertPoints(initPts, false);

    if(cvMeshControls().objOutput())
    {
        writePoints("initialPoints.obj", true);
    }

}


bool Foam::conformalVoronoiMesh::distributeBackground()
{
    if (!Pstream::parRun())
    {
        return false;
    }

    Info<< nl << "Redistributing points" << endl;

    timeCheck("Before distribute");

    label iteration = 0;

    while (true)
    {
        label nRealVertices = 0;

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            // Only store real vertices that are not feature vertices
            if (vit->real() && vit->index() >= startOfInternalPoints_)
            {
                nRealVertices++;
            }
        }

        scalar globalNRealVertices = returnReduce
        (
            nRealVertices,
            sumOp<label>()
        );

        scalar unbalance = returnReduce
        (
            mag(1.0 - nRealVertices/(globalNRealVertices/Pstream::nProcs())),
            maxOp<scalar>()
        );

        Info<< "    Processor unbalance " << unbalance << endl;

        if (unbalance <= cvMeshControls().maxLoadUnbalance())
        {
            // If this is the first iteration, return false, if it was a
            // subsequent one, return true;
            return iteration != 0;
        }

        Info<< "    Total number of vertices before redistribution "
            << globalNRealVertices
            << endl;

        // Pout<< "    Real vertices before distribution "
        //     << nRealVertices << endl;

        const fvMesh& bMesh = decomposition_().mesh();

        volScalarField cellWeights
        (
            IOobject
            (
                "cellWeights",
                bMesh.time().timeName(),
                bMesh,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            bMesh,
            dimensionedScalar("weight", dimless, 1e-3),
            zeroGradientFvPatchScalarField::typeName
        );

        meshSearch cellSearch(bMesh);

        List<DynamicList<Foam::point> > cellVertices(bMesh.nCells());
        List<DynamicList<label> > cellVertexIndices(bMesh.nCells());
        List<DynamicList<label> > cellVertexTypes(bMesh.nCells());

        for
        (
            Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
            vit != finite_vertices_end();
            vit++
        )
        {
            // Only store real vertices that are not feature vertices
            if (vit->real() && vit->index() >= startOfInternalPoints_)
            {
                Foam::point v = topoint(vit->point());

                label cellI = cellSearch.findCell(v);

                if (cellI == -1)
                {
                    Pout<< "findCell conformalVoronoiMesh::distribute findCell "
                        << vit->type() << " "
                        << vit->index() << " "
                        << v << " "
                        << cellI
                        << " find nearest cellI ";

                    cellI = cellSearch.findNearestCell(v);

                    Pout<< cellI << endl;
                }

                cellVertices[cellI].append(topoint(vit->point()));
                cellVertexIndices[cellI].append(vit->index());
                cellVertexTypes[cellI].append(vit->type());
            }
        }

        forAll(cellVertices, cI)
        {
            // Give a small but finite weight for empty cells.  Some
            // decomposition methods have difficulty with integer overflows in
            // the sum of the normalised weight field.
            cellWeights.internalField()[cI] = max
            (
                cellVertices[cI].size(),
                1e-2
            );
        }

        autoPtr<mapDistributePolyMesh> mapDist = decomposition_().distribute
        (
            cellWeights,
            cellVertices,
            cellVertexIndices,
            cellVertexTypes
        );

        // Remove the entire tessellation
        reset();

        // Reinsert feature points, distributing them as necessary.
        reinsertFeaturePoints(true);

        startOfInternalPoints_ = number_of_vertices();

        timeCheck("Distribution performed");

        Info<< nl << "    Inserting distributed tessellation" << endl;

        DynamicList<Foam::point> pointsToInsert;
        DynamicList<label> indices;
        DynamicList<label> types;

        forAll(cellVertices, cI)
        {
            forAll(cellVertices[cI], cVPI)
            {
                pointsToInsert.append(cellVertices[cI][cVPI]);

                // All insertions relative to index of zero
                indices.append(0);

                label type = cellVertexTypes[cI][cVPI];

                if (type > Vb::ptFarPoint)
                {
                    // This is a member of a point pair, don't use the type
                    // directly, make type relative to the index in preparation
                    // for insertion.

                    type -= cellVertexIndices[cI][cVPI];
                }

                types.append(type);
            }
        }

        // Assume that the distribution made the correct decision for which
        // processor each point should be on, so give distribute = false
        insertPoints(pointsToInsert, indices, types, false);

        // Adjust by 8 because of insertion of bounding points by reset
        Info<< "    Total number of vertices after redistribution "
            << returnReduce(label(number_of_vertices() - 8), sumOp<label>())
            << endl;

        // Pout<< "    Real vertices after distribution "
        //     << label(number_of_vertices() - 8) << endl;

        if(cvMeshControls().objOutput())
        {
            writePoints("distributedPoints.obj", true);
        }

        timeCheck("After distribute");

        iteration++;
    }

    return true;
}


void Foam::conformalVoronoiMesh::storeSizesAndAlignments()
{
    std::list<Point> storePts;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->internalPoint())
        {
            storePts.push_back(vit->point());
        }
    }

    storeSizesAndAlignments(storePts);
}


void Foam::conformalVoronoiMesh::storeSizesAndAlignments
(
    const std::list<Point>& storePts
)
{
    timeCheck("Start of storeSizesAndAlignments");

    Info << nl << "Store size and alignment" << endl;

    sizeAndAlignmentLocations_.setSize(storePts.size());

    storedSizes_.setSize(sizeAndAlignmentLocations_.size());

    storedAlignments_.setSize(sizeAndAlignmentLocations_.size());

    label i = 0;

    for
    (
        std::list<Point>::const_iterator pit=storePts.begin();
        pit != storePts.end();
        ++pit
    )
    {
        sizeAndAlignmentLocations_[i] = topoint(*pit);

        storedSizes_[i] = cellSizeControl().cellSize
        (
            sizeAndAlignmentLocations_[i],
            false
        );

        storedAlignments_[i] = requiredAlignment(sizeAndAlignmentLocations_[i]);

        i++;
    }

    timeCheck("Sizes and alignments calculated, build tree");

    buildSizeAndAlignmentTree();

    timeCheck("Size and alignment tree built");
}


void Foam::conformalVoronoiMesh::updateSizesAndAlignments
(
    const std::list<Point>& storePts
)
{
    if
    (
        runTime_.run()
     && runTime_.timeIndex()
      % cvMeshControls().sizeAndAlignmentRebuildFrequency() == 0
    )
    {
        storeSizesAndAlignments(storePts);

        timeCheck("Updated sizes and alignments");
    }
}


const Foam::indexedOctree<Foam::treeDataPoint>&
Foam::conformalVoronoiMesh::sizeAndAlignmentTree() const
{
    if (sizeAndAlignmentTreePtr_.empty())
    {
        buildSizeAndAlignmentTree();
    }

    return sizeAndAlignmentTreePtr_();
}


void Foam::conformalVoronoiMesh::setVertexSizeAndAlignment()
{
    Info<< nl << "Looking up target cell alignment and size" << endl;

    const indexedOctree<treeDataPoint>& tree = sizeAndAlignmentTree();

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        vit++
    )
    {
        if (vit->internalOrBoundaryPoint())
        {
            Foam::point pt(topoint(vit->point()));

            pointIndexHit info = tree.findNearest(pt, sqr(GREAT));

            if (info.hit())
            {
                vit->alignment() = storedAlignments_[info.index()];

                vit->targetCellSize() = storedSizes_[info.index()];
            }
            else
            {
                WarningIn
                (
                    "void "
                    "Foam::conformalVoronoiMesh::setVertexSizeAndAlignment()"
                )
                    << "Point " << pt << " did not find a nearest point "
                    << " for alignment and size lookup." << endl;

                vit->alignment() = requiredAlignment(pt);

                vit->targetCellSize() = cellSizeControl().cellSize(pt, false);
            }
        }
    }

    // Info<< nl << "Calculating target cell alignment and size" << endl;

    // for
    // (
    //     Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
    //     vit != finite_vertices_end();
    //     vit++
    // )
    // {
    //     if (vit->internalOrBoundaryPoint())
    //     {
    //         point pt(topoint(vit->point()));

    //         vit->alignment() = requiredAlignment(pt);

    //         vit->targetCellSize() = targetCellSize(pt);
    //     }
    // }
}


Foam::face Foam::conformalVoronoiMesh::buildDualFace
(
    const Delaunay::Finite_edges_iterator& eit
) const
{
    Cell_circulator ccStart = incident_cells(*eit);
    Cell_circulator cc1 = ccStart;
    Cell_circulator cc2 = cc1;

    // Advance the second circulator so that it always stays on the next
    // cell around the edge;
    cc2++;

    DynamicList<label> verticesOnFace;

    label nUniqueVertices = 0;

    do
    {
        label cc1I = cc1->cellIndex();

        label cc2I = cc2->cellIndex();

        if (cc1I < 0 || cc2I < 0)
        {
            Cell_handle c = eit->first;
            Vertex_handle vA = c->vertex(eit->second);
            Vertex_handle vB = c->vertex(eit->third);

            FatalErrorIn("Foam::conformalVoronoiMesh::buildDualFace")
                << "Dual face uses circumcenter defined by a "
                << "Delaunay tetrahedron with no internal "
                << "or boundary points.  Defining Delaunay edge ends: "
                << topoint(vA->point()) << " "
                << topoint(vB->point()) << nl
                << exit(FatalError);
        }

        if (cc1I != cc2I)
        {
            if (findIndex(verticesOnFace, cc1I) == -1)
            {
                nUniqueVertices++;
            }

            verticesOnFace.append(cc1I);
        }

        cc1++;

        cc2++;

    } while (cc1 != ccStart);

    if (verticesOnFace.size() >= 3 && nUniqueVertices < 3)
    {
        // There are not enough unique vertices on this face to
        // justify its size, it may have a form like:

        // Vertices:
        // A                                  B
        // A                                  B

        // Face:
        // ABAB

        // Setting the size to be below 3, so that it will not be
        // created

        verticesOnFace.setSize(nUniqueVertices);
    }

    return face(verticesOnFace);
}


Foam::label Foam::conformalVoronoiMesh::maxFilterCount
(
    const Delaunay::Finite_edges_iterator& eit
) const
{
    Cell_circulator ccStart = incident_cells(*eit);
    Cell_circulator cc = ccStart;

    label maxFC = 0;

    do
    {
        if (cc->cellIndex() < 0)
        {
            Cell_handle c = eit->first;
            Vertex_handle vA = c->vertex(eit->second);
            Vertex_handle vB = c->vertex(eit->third);

            FatalErrorIn("Foam::conformalVoronoiMesh::buildDualFace")
                << "Dual face uses circumcenter defined by a "
                << "Delaunay tetrahedron with no internal "
                << "or boundary points.  Defining Delaunay edge ends: "
                << topoint(vA->point()) << " "
                << topoint(vB->point()) << nl
                << exit(FatalError);
        }

        if (cc->filterCount() > maxFC)
        {
            maxFC = cc->filterCount();
        }

        cc++;

    } while (cc != ccStart);

    return maxFC;
}


bool Foam::conformalVoronoiMesh::ownerAndNeighbour
(
    Vertex_handle vA,
    Vertex_handle vB,
    label& owner,
    label& neighbour
) const
{
    bool reverse = false;

    owner = -1;
    neighbour = -1;

    label dualCellIndexA = vA->index();

    if (!vA->internalOrBoundaryPoint())
    {
        dualCellIndexA = -1;
    }

    label dualCellIndexB = vB->index();

    if (!vB->internalOrBoundaryPoint())
    {
        dualCellIndexB = -1;
    }

    if (dualCellIndexA == -1 && dualCellIndexB == -1)
    {
        FatalErrorIn
        (
            "bool Foam::conformalVoronoiMesh::ownerAndNeighbour"
            "("
                "Vertex_handle vA,"
                "Vertex_handle vB,"
                "label& owner,"
                "label& neighbour"
            ") const"
        )
            << "Attempting to create a face joining "
            << "two unindexed dual cells "
            << exit(FatalError);
    }
    else if (dualCellIndexA == -1 || dualCellIndexB == -1)
    {
        // boundary face, find which is the owner

        if (dualCellIndexA == -1)
        {
            owner = dualCellIndexB;

            reverse = true;
        }
        else
        {
            owner = dualCellIndexA;
        }
    }
    else
    {
        // internal face, find the lower cell to be the owner

        if (dualCellIndexB > dualCellIndexA)
        {
            owner = dualCellIndexA;
            neighbour = dualCellIndexB;
        }
        else
        {
            owner = dualCellIndexB;
            neighbour = dualCellIndexA;

            // reverse face order to correctly orientate normal
            reverse = true;
        }
    }

    return reverse;
}


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::conformalVoronoiMesh::conformalVoronoiMesh
(
    const Time& runTime,
    const dictionary& cvMeshDict
)
:
    Delaunay(),
    runTime_(runTime),
    rndGen_(64293*Pstream::myProcNo()),
    cvMeshControls_(*this, cvMeshDict),
    allGeometry_
    (
        IOobject
        (
            "cvSearchableSurfaces",
            runTime_.constant(),
            "triSurface",
            runTime_,
            IOobject::MUST_READ,
            IOobject::NO_WRITE
        ),
        cvMeshDict.subDict("geometry")
    ),
    geometryToConformTo_
    (
        *this,
        allGeometry_,
        cvMeshDict.subDict("surfaceConformation")
    ),
    cellSizeControl_
    (
        *this,
        allGeometry_,
        cvMeshDict.subDict("motionControl")
    ),
    startOfInternalPoints_(0),
    featureVertices_(),
    featurePointLocations_(),
    featurePointTreePtr_(),
    sizeAndAlignmentLocations_(),
    storedSizes_(),
    storedAlignments_(),
    sizeAndAlignmentTreePtr_(),
    surfaceConformationVertices_(),
    initialPointsMethod_
    (
        initialPointsMethod::New
        (
            cvMeshDict.subDict("initialPoints"),
            *this
        )
    ),
    relaxationModel_
    (
        relaxationModel::New
        (
            cvMeshDict.subDict("motionControl"),
            *this
        )
    ),
    faceAreaWeightModel_
    (
        faceAreaWeightModel::New
        (
            cvMeshDict.subDict("motionControl"),
            *this
        )
    ),
    decomposition_()
{
    if (Pstream::parRun())
    {
        decomposition_.reset
        (
            new backgroundMeshDecomposition
            (
                cvMeshDict.subDict("backgroundMeshDecomposition"),
                *this
            )
        );
    }

    if (cvMeshControls().objOutput())
    {
        geometryToConformTo_.writeFeatureObj("cvMesh");
    }

    insertBoundingPoints();

    insertFeaturePoints();

    insertInitialPoints();

    // Improve the guess that the backgroundMeshDecomposition makes with the
    // initial positions.  Use before building the surface conformation to
    // better balance the surface conformation load.
    distributeBackground();

    buildSurfaceConformation(rmCoarse);

    // The introduction of the surface conformation may have distorted the
    // balance of vertices, distribute if necessary.
    if (distributeBackground())
    {
        // distributeBackground has destroyed all referred vertices, so the
        // parallel interface needs to be rebuilt.

        buildParallelInterface("rebuild");
    }

    // Do not store the surface conformation until after it has been
    // (potentially) redistributed.
    storeSurfaceConformation();

    // Use storeSizesAndAlignments with no feed points because all background
    // points may have been distributed.  It is a requirement that none of the
    // preceding functions requires look up of sizes or alignments from the
    // Delaunay vertices, i.e. setVertexSizeAndAlignment cannot be called
    // before this point.
    storeSizesAndAlignments();

    // Report any Delaunay vertices that do not think that they are in the
    // domain the processor they are on.
    reportProcessorOccupancy();

    if(cvMeshControls().objOutput())
    {
        writePoints("allInitialPoints.obj", false);
    }
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

Foam::conformalVoronoiMesh::~conformalVoronoiMesh()
{}


// * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * * //

void Foam::conformalVoronoiMesh::move()
{
    timeCheck("Start of move");

    scalar relaxation = relaxationModel_->relaxation();

    Info<< nl << "Relaxation = " << relaxation << endl;

    pointField dualVertices(number_of_cells());

    label dualVertI = 0;

    // Find the dual point of each tetrahedron and assign it an index.
    for
    (
        Delaunay::Finite_cells_iterator cit = finite_cells_begin();
        cit != finite_cells_end();
        ++cit
    )
    {
        cit->cellIndex() = -1;

        if
        (
            cit->vertex(0)->internalOrBoundaryPoint()
         || cit->vertex(1)->internalOrBoundaryPoint()
         || cit->vertex(2)->internalOrBoundaryPoint()
         || cit->vertex(3)->internalOrBoundaryPoint()
        )
        {
            cit->cellIndex() = dualVertI;

            dualVertices[dualVertI] = topoint(dual(cit));

            dualVertI++;
        }
    }

    dualVertices.setSize(dualVertI);

    setVertexSizeAndAlignment();

    timeCheck("Determined sizes and alignments");

    Info<< nl << "Determining vertex displacements" << endl;

    vectorField cartesianDirections(3);

    cartesianDirections[0] = vector(0,0,1);
    cartesianDirections[1] = vector(0,1,0);
    cartesianDirections[2] = vector(1,0,0);

    vectorField displacementAccumulator
    (
        number_of_vertices(),
        vector::zero
    );

    PackedBoolList pointToBeRetained(number_of_vertices(), true);

    std::list<Point> pointsToInsert;

    label pointsAdded = 0;

    for
    (
        Delaunay::Finite_edges_iterator eit = finite_edges_begin();
        eit != finite_edges_end();
        ++eit
    )
    {
        if
        (
            eit->first->vertex(eit->second)->internalOrBoundaryPoint()
         && eit->first->vertex(eit->third)->internalOrBoundaryPoint()
        )
        {
            face dualFace = buildDualFace(eit);

            Cell_handle c = eit->first;
            Vertex_handle vA = c->vertex(eit->second);
            Vertex_handle vB = c->vertex(eit->third);

            Foam::point dVA = topoint(vA->point());
            Foam::point dVB = topoint(vB->point());

            Field<vector> alignmentDirsA(vA->alignment() & cartesianDirections);
            Field<vector> alignmentDirsB(vB->alignment() & cartesianDirections);

            Field<vector> alignmentDirs(3);

            forAll(alignmentDirsA, aA)
            {
                const vector& a(alignmentDirsA[aA]);

                scalar maxDotProduct = 0.0;

                forAll(alignmentDirsB, aB)
                {
                    const vector& b(alignmentDirsB[aB]);

                    scalar dotProduct = a & b;

                    if (mag(dotProduct) > maxDotProduct)
                    {
                        maxDotProduct = mag(dotProduct);

                        alignmentDirs[aA] = a + sign(dotProduct)*b;

                        alignmentDirs[aA] /= mag(alignmentDirs[aA]);
                    }
                }
            }

            vector rAB = dVA - dVB;

            scalar rABMag = mag(rAB);

            if (rABMag < SMALL)
            {
                // Removal of close points

                if (vA->internalPoint() && vB->internalPoint())
                {
                    // Only insert a point at the midpoint of
                    // the short edge if neither attached
                    // point has already been identified to be
                    // removed.

                    if
                    (
                        pointToBeRetained[vA->index()] == true
                     && pointToBeRetained[vB->index()] == true
                    )
                    {
                        pointsToInsert.push_back
                        (
                            toPoint(0.5*(dVA + dVB))
                        );
                    }
                }

                if (vA->internalPoint())
                {
                    pointToBeRetained[vA->index()] = false;
                }

                if (vB->internalPoint())
                {
                    pointToBeRetained[vB->index()] = false;
                }

                // Do not consider this Delaunay edge any further

                continue;
            }

            forAll(alignmentDirs, aD)
            {
                vector& alignmentDir = alignmentDirs[aD];

                if ((rAB & alignmentDir) < 0)
                {
                    // swap the direction of the alignment so that has the
                    // same sense as rAB
                    alignmentDir *= -1;
                }

                scalar alignmentDotProd = ((rAB/rABMag) & alignmentDir);

                if
                (
                    alignmentDotProd
                  > cvMeshControls().cosAlignmentAcceptanceAngle()
                )
                {
                    scalar targetCellSize = averageCellSize(vA, vB);

                    scalar targetFaceArea = sqr(targetCellSize);

                    alignmentDir *= 0.5*targetCellSize;

                    vector delta = alignmentDir - 0.5*rAB;

                    scalar faceArea = dualFace.mag(dualVertices);

                    delta *= faceAreaWeightModel_->faceAreaWeight
                    (
                        faceArea/targetFaceArea
                    );

                    if
                    (
                        vA->internalPoint()
                     && vB->internalPoint()
                     && rABMag
                      > cvMeshControls().insertionDistCoeff()*targetCellSize
                     && faceArea
                      > cvMeshControls().faceAreaRatioCoeff()*targetFaceArea
                     && alignmentDotProd
                      > cvMeshControls().cosInsertionAcceptanceAngle()
                    )
                    {
                        // Point insertion

                        if
                        (
                            !geometryToConformTo_.findSurfaceAnyIntersection
                            (
                                dVA,
                                dVB
                            )
                        )
                        {
                            // Prevent insertions spanning surfaces

                            pointsToInsert.push_back
                            (
                                toPoint(0.5*(dVA + dVB))
                            );

                            pointsAdded++;
                        }
                    }
                    else if
                    (
                        (vA->internalPoint() || vB->internalPoint())
                     && rABMag
                      < cvMeshControls().removalDistCoeff()*targetCellSize
                    )
                    {
                        // Point removal

                        if (vA->internalPoint() && vB->internalPoint())
                        {
                            // Only insert a point at the midpoint of
                            // the short edge if neither attached
                            // point has already been identified to be
                            // removed.

                            if
                            (
                                pointToBeRetained[vA->index()] == true
                             && pointToBeRetained[vB->index()] == true
                            )
                            {
                                pointsToInsert.push_back
                                (
                                    toPoint(0.5*(dVA + dVB))
                                );
                            }
                        }

                        if (vA->internalPoint())
                        {
                            pointToBeRetained[vA->index()] = false;
                        }

                        if (vB->internalPoint())
                        {
                            pointToBeRetained[vB->index()] = false;
                        }
                    }
                    else
                    {
                        if (vA->internalPoint())
                        {
                            displacementAccumulator[vA->index()] += delta;
                        }

                        if (vB->internalPoint())
                        {
                            displacementAccumulator[vB->index()] += -delta;
                        }
                    }
                }
            }
        }
    }

    // Limit displacements that pierce, or get too close to the surface
    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->internalPoint())
        {
            limitDisplacement
            (
                vit,
                displacementAccumulator[vit->index()]
            );
        }
    }

    vector totalDisp = sum(displacementAccumulator);
    scalar totalDist = sum(mag(displacementAccumulator));

    // Relax the calculated displacement
    displacementAccumulator *= relaxation;

    for
    (
        Delaunay::Finite_vertices_iterator vit = finite_vertices_begin();
        vit != finite_vertices_end();
        ++vit
    )
    {
        if (vit->internalPoint())
        {
            if (pointToBeRetained[vit->index()] == true)
            {
                // Convert vit->point() to FOAM vector (double) to do addition,
                // avoids memory increase because a record of the constructions
                // would be kept otherwise.
                // See cgal-discuss@lists-sop.inria.fr:
                // "Memory issue with openSUSE 11.3, exact kernel, adding
                //  points/vectors"
                // 14/1/2011.
                // Only necessary if using an exact constructions kernel
                // (extended precision)

                pointsToInsert.push_back
                (
                    toPoint
                    (
                        topoint(vit->point())
                      + displacementAccumulator[vit->index()]
                    )
                );
            }
        }
    }

    // Remove the entire tessellation
    reset();

    reinsertFeaturePoints();

    startOfInternalPoints_ = number_of_vertices();

    timeCheck("Displacement calculated");

    Info<< nl << "Inserting displaced tessellation" << endl;

    insertPoints(pointsToInsert);

    label pointsRemoved =
        displacementAccumulator.size()
      - number_of_vertices()
      + pointsAdded;

    timeCheck("Internal points inserted");

    conformToSurface();

    timeCheck("After conformToSurface");

    updateSizesAndAlignments(pointsToInsert);

    buildParallelInterface("move_" + runTime_.timeName());

    // Write the intermediate mesh, do not filter the dual faces.
    if (runTime_.outputTime())
    {
        writeMesh(runTime_.timeName(), false);
    }

    Info<< nl
        << "Total displacement = " << totalDisp << nl
        << "Total distance = " << totalDist << nl
        << "Points added = " << pointsAdded << nl
        << "Points removed = " << pointsRemoved
        << endl;
}


bool Foam::conformalVoronoiMesh::positionOnThisProc
(
    const Foam::point& pt
) const
{
    if (Pstream::parRun())
    {
        return decomposition_().positionOnThisProcessor(pt);
    }

    return true;
}


Foam::boolList Foam::conformalVoronoiMesh::positionOnThisProc
(
    const Foam::pointField& pts
) const
{
    if (Pstream::parRun())
    {
        return decomposition_().positionOnThisProcessor(pts);
    }

    return boolList(pts.size(), true);
}


Foam::labelList Foam::conformalVoronoiMesh::positionProc
(
    const Foam::pointField& pts
) const
{
    if (!Pstream::parRun())
    {
        return labelList(pts.size(), -1);
    }

    return decomposition_().processorPosition(pts);
}


Foam::List<Foam::List<Foam::pointIndexHit> >
Foam::conformalVoronoiMesh::intersectsProc
(
    const pointField& starts,
    const pointField& ends
) const
{
    if (!Pstream::parRun())
    {
        return List<List<pointIndexHit> >(starts.size());
    }

    return decomposition_().intersectsProcessors(starts, ends, false);
}


Foam::labelListList Foam::conformalVoronoiMesh::overlapsProc
(
    const pointField& centres,
    const scalarField& radiusSqrs
) const
{
    if (!Pstream::parRun())
    {
        return labelListList(centres.size(), labelList(0));
    }

    return decomposition_().overlapsProcessors(centres, radiusSqrs, false);
}


// ************************************************************************* //
