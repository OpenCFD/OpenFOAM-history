# -*- text-*-
#
# Copyright (c) 2001-2004 The Trustees of Indiana University.  
#                         All rights reserved.
# Copyright (c) 1998-2001 University of Notre Dame. 
#                         All rights reserved.
# Copyright (c) 1994-1998 The Ohio State University.  
#                         All rights reserved.
# 
# This file is part of the LAM/MPI software package.  For license
# information, see the LICENSE file in the top level directory of the
# LAM/MPI source distribution.
# 
# $HEADER$
# 
# $Id: lam-helpfile,v 1.111 2004/03/09 16:56:05 pcharapa Exp $
#
# ASCII help messages for LAM
#
-*-ALL:unknown-*-
# This is invoked when we have no idea what happened
# %1 = Name of the program
%1: Oops -- some unknown error happened here.  Not really sure what
happened to cause this.  

This might be helpful -- here's what Unix thinks the error is:

        Unix errno: %errno
        %perror
-*-ALL:system-call-fail-*-
# Invoked when some system call fails.  This is not good!
# %1 = name of system call that failed
LAM encountered an error when invoking the system call "%1".

This is an unexpected error; we don't have much additional information
here.  Perhaps this Unix error message will help:

        Unix errno: %errno
        %perror
-*-ALL:lib-call-fail-*-
# Invoked when some system call fails.  This is not good!
# %1 = name of system call that failed
LAM encountered an error when invoking the library call "%1".

This is an unexpected error; we don't have much additional information
here.  Perhaps this Unix error message will help:

        Unix errno: %errno
        %perror
-*-ALL:deny-root-*-
# This message is displayed when any LAM program is invoked by root.
# No parameters are sent.
It is a Very Bad Idea to run this program as root.

LAM was designed to be run by individual users; it was *not* designed
to be run as a root-level service where multiple users use the same
LAM daemons in a client-server fashion.

Especially with today's propensity for hackers to scan for root-owned
network daemons, it could be tragic to run this program as root.
While LAM is known to be quite stable, and LAM does not leave network
sockets open for random connections after the initial setup, several
factors should strike fear into system administrator's hearts if LAM
were to be constantly running for all users to utilize:

        1. LAM leaves a Unix domain socket open on each machine in the
           /tmp directory.  So if someone breaks into root on one
           machine, they effectively have root on all machines that
           are connected via LAM.  

        2. Indeed, there must have been a .rhosts (or some other trust
           mechanism) for root which must have allowed you to run LAM
           on remote nodes.  Depending on your local setup, this may
           not be safe.

        3. LAM has never been checked for buffer overflows and other
           malicious input types of errors.  We don't *think* that
           there are any buffer-overflow types of situations in LAM,
           we've never checked explicitly (hence, per Mr. Murphy,
           there are certainly some hiding somewhere).

        4. LAM programs are not audited or tracked in any way.  This
           could present a sneaky way to execute binaries without log
           trails (especially as root).

Hence, it's a Very Bad Idea to run LAM as root.  Please login as a
different user and run LAM again.
-*-ALL:root-warning-*-
# This message is displayed when recon is invoked by root.
# No parameters are sent.
Warning: You are invoking this program as root.  All other LAM executables
are not allowed to be run as root for security reasons.  The use of recon 
is allowed because of the common need for system administrators to validate
a LAM installation.
-*-ALL:close-file-*-
# Invoked by anyone when the user-provided host file could not be 
# closed properly.
# %1 = name of the invoking entity
# %2 = name of the host file 
%1 could not close the file "%2" for the following reason:

        Unix errno: %errno
        %perror
-*-ALL:open-file-*-
# Invoked by anyone when the user-provided host file could not be opened
# %1 = name of the invoking entity
# %2 = name of the host file 
%1 could not open the file "%2" for the following reason:

        Unix errno: %errno
        %perror
Things to check:

        - ensure that the file exists
          try "ls -l %2"
        - ensure that you have read permissions on the file
          try "cat %2"
-*-ALL:abnormal-exit-*-
# Invoked when a process unexpectedly returns a nonzero exit status
# No parameters are passed
One of the processes started has exited with a nonzero exit code.
This typically indicates that the process finished in error.
Hopefully, this error is displayed above.
-*-ALL:uninitialized-*-
# This message is displayed when some program invokes an MPI function
# (not including MPI_Initialized) before invoking MPI_Init
# %1 is the hostname
# %2 is the PID
It seems that at least one rank invoked some MPI function before
invoking MPI_INIT.  The only information that I can give is that it
was PID %2 on host %1.
-*-ALL:already-finalized-*-
# This message is displayed when some program invokes an MPI function
# (not including MPI_Initialized) after invoking MPI_Finalize
# %1 is the hostname
# %2 is the PID
# %3 the rank in MPI_COMM_WORLD
It seems that at least one rank invoked some MPI function after
invoking MPI_FINALIZE.  The only information that I can give is that
it was PID %2 on host %1.  

It was probably rank %3 on MPI_COMM_WORLD, but I can't say that for 
sure...
-*-ALL:init-after-finalize-*-
# This message is displayed when some program invokes MPI_INIT
# after invoking MPI_FINALIZE.
# %1 is the hostname
# %2 is the PID
# %3 is the rank in MPI_COMM_WORLD
It seems that at least one rank invoked MPI_INIT after invoking
MPI_FINALIZE.  MPI can not be re-initialized after MPI_FINALIZE has
been called.  The process was PID %2 on host %1.

It was probably rank %3 on MPI_COMM_WORLD, but I can't say that for
sure...
-*-ALL:unable-rmdir-*-
# This message is displayed if there is some error while trying to remove
# a directory.  This is typically in tkill when trying to remove the 
# internal LAM session directory.  If you see this message, something is
# very wrong, and probably requires manual intervention.
# %1 name of program with problem
# %2 directory that can't be removed
It seems that LAM was not able to remove a directory properly.  This should
not happen, and will probably require manual intervention on your part.  
%1 was trying to remove the following directory:

        %2

when some error occurred.  Perhaps the following Unix error message will 
help:

        Unix errno: %errno
        %perror

This directory contains some internal temporary LAM files, and is safe
to remove.  Please go remove it manually.
-*-ALL:version-mismatch-*-
# In kinit, right after we attach and register with the lamd, we call
# down to the lamd and compare our version string with the version
# that we were compiled with.  If we don't match, print out this
# warning and then bail.
# %1: Version that we were compiled against
# %2: Version that the lamd was compiled against
WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!

The program that you are attempting to run is compiled against LAM/MPI
version %1, but the LAM run-time environment that is currently running
is %2.

This mismatch means that things may not work properly -- we *highly*
recommend either recompiling your program with LAM/MPI version %2, or
running the LAM/MPI run-time environment version %1.

Aborting...

WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
-*-ALL:unable-to-check-version-*-
# In kinit, right after we attach and register with the lamd, we call
# down to the lamd and compare our version string with the version
# that we were compiled with.  If the version check fails for some
# reason (i.e., we were unable to query the lamd for the version),
# print this message.
# %1: Version that we were compiled against
WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!

The program that you are attempting to run is compiled against LAM/MPI
version %1, but is unable to check the LAM run-time environment for
what version it is.  

This mismatch means that things may not work properly -- we *highly*
recommend either recompiling your program with the same version of
LAM/MPI as the currently-running run-time environment, or running the
LAM/MPI run-time environment version %1.

Aborting...

WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
-*-bforward:usage-*-
# Show the usage options of the "bforward" daemon
# No parameters are sent
Synopsis:       lamd_bforward [-d] [-b <sockname>]

Description:    Bufferd helper daemon

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-bufferd:usage-*-
# Show the usage options of the "buffer" daemon
# No parameters are sent
Synopsis:       lamd_bufferd [-d] [-b <sockname>]

Description:    Message buffer daemon

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-dli_inet:usage-*-
# Show the usage options of the "dli_inet" daemon
# No parameters are sent
Synopsis:       lamd_dli_inet [-x] [-d] [-b <sockname>] [-c <cpu count>]
                              [-n <my nodeid>] [-o <origin nodeid>]
                              [-p <port num>] [-H <agent addr>]
                              [-P <port num>]

Description:    Incoming Datalink communication daemon

Options:
        -b      Use <sockname> for the socket suffix
        -c      Assume machine has <cpu count> cpus
        -n      Assume my node id is <my nodeid>
        -H      Boot agent address is <agent addr>
        -o      Assume origin node is <origin nodeid>
        -p      dli port number <port num>
        -P      Use <port num> as agent port number
        -d      Print debugging messages
        -x      Run in fault tolerant mode
-*-dlo_inet:usage-*-
# Show the usage options of the "dli_inet" daemon
# No parameters are sent
Synopsis:       lamd_dlo_inet [-d] [-b <sockname>]

Description:    Outgoing Datalink communication daemon

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-echod:usage-*-
# Show the usage options of the "echod" daemon
# No parameters are sent
Synopsis:       lamd_echod [-d] [-b <sockname>]

Description:    "echo" server - like the Unix echo service

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-filed:usage-*-
# Show the usage options of the "filed" daemon
# No parameters are sent
Synopsis:       lamd_filed [-d] [-b <sockname>]

Description:    Remote file server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-flatd:usage-*-
# Show the usage options of the "flatd" daemon
# No parameters are sent
Synopsis:       lamd_flatd [-d] [-b <sockname>]

Description:    Flat storage server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-haltd:usage-*-
# Show the usage options of the "flatd" daemon
# No parameters are sent
Synopsis:       lamd_flatd [-d] [-b <sockname>]

Description:    Flat storage server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-iod:usage-*-
# Show the usage options of the "flatd" daemon
# No parameters are sent
Synopsis:       lamd_flatd [-d] [-b <sockname>]

Description:    Flat storage server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-kenyad:usage-*-
# Show the usage options of the "flatd" daemon
# No parameters are sent
Synopsis:       lamd_flatd [-d] [-b <sockname>]

Description:    Flat storage server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-kernel:usage-*-
# Show the usage options of the "kernel"
# No parameters are sent
Synopsis:       lamd_kernel [-d] [-b <sockname>]

Description:    LAM kernel

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-lamd:usage-*-
# Show the usage options of the "lam" daemon
# No parameters are sent
Synopsis:       lamd [-x] [-d] [-b <sockname>] [-c <cpu count>]
                     [-n <my nodeid>] [-o <origin nodeid>]
                     [-p <port num>] [-H <agent addr>]
                     [-P <port num>]

Description:    LAM all-in-one daemon

Options:
        -b      Use <sockname> for the socket suffix
        -c      Assume machine has <cpu count> cpus
        -n      Assume my node id is <my nodeid>
        -H      Boot agent address is <agent addr>
        -o      Assume origin node is <origin nodeid>
        -p      dli port number <port num>
        -P      Use <port num> as agent port number
        -d      Print debugging messages
        -x      Run in fault tolerant mode
-*-loadd:usage-*-
# Show the usage options of the "loadd" daemon
# No parameters are sent
Synopsis:       lamd_loadd [-d] [-b <sockname>]

Description:    Remote file transfer server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-router:usage-*-
# Show the usage options of the "router" daemon
# No parameters are sent
Synopsis:       lamd_router [-d] [-b <sockname>]

Description:    Router server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-traced:usage-*-
# Show the usage options of the "traced" daemon
# No parameters are sent
Synopsis:       lamd_traced [-d] [-b <sockname>]

Description:    Trace server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-versiond:usage-*-
# Show the usage options of the "versiond" daemon
# No parameters are sent
Synopsis:       lamd_versiond [-d] [-b <sockname>]

Description:    Version information server

Options:
        -b      Use <sockname> for the socket suffix
        -d      Print debugging messages
-*-lam-temp-files:badness-*-
# When we fail to create the /tmp/lam-* directory and/or files for
# temporary data in this run-time environment instance, display this
# error message.
# %1 = name of upper-level LAM library call/program that had a problem
At lamboot time, LAM stores some run-time files for each user under
the /tmp directory.  This error was caused by the fact that LAM either
could not create a directory (or files in that directory), or was not
able to remove an old directory that already exists (or any files in
that previously-existing directory).

This error occurred in: %1

Things to check:

        - /tmp exists and has permissions 0777
        - No files/directories exist in /tmp that begin with "lam-"
          and have your username in them that you do not have
          permissions to remove
-*-recon:usage-*-
# Show the usage options of the "recon" program
# No parameters are sent
Synopsis:       recon [-a] [-d] [-h] [-v] [-nn] [-np] [<bhost>]

Description:    Check if LAM can be booted

Options:
        -a      Report all errors (as opposed to quitting after the first 
                error)
        -b      Use the faster recon algorithm; will only work if shell
                on all remote nodes is same as shell on local node
        -d      Print debugging messages (implies -v)
        -h      Print this message
        -nn     Don't add "-n" to the remote agent command line
        -np     Do not force the execution of $HOME/.profile on remote hosts
        -v      Be verbose
        <bhost> Use <bhost> as the boot schema
-*-boot:bhostparse-*-
# Invoked by any booting program (e.g., lamboot, recon) when the
# user-provided host file could not be parsed properly.
# %1 = name of the invoking program
# %2 = name of the host file that we tried to parse
%1 could not parse the hostfile "%2" for the following reason:

        %terror
-*-boot:close-hostfile-*-
# Invoked by any booting program (e.g., lamboot, recon) when the
# user-provided host file could not be closed properly
# %1 = name of the invoking program
# %2 = name of the host file 
%1 could not close the hostfile "%2" for the following reason:

        Unix errno: %errno
        %perror
-*-boot:open-hostfile-*-
# Invoked by any booting program (e.g., lamboot, recon) when the
# user-provided host file could not be opened
# %1 = name of the invoking program
# %2 = name of the host file 
%1 could not open the hostfile "%2" for the following reason:

        Unix errno: %errno
        %perror
Things to check:

        - ensure that the file exists
          try "ls -l %2"
        - ensure that you have read permissions on the file
          try "cat %2"
-*-boot:find-hostfile-*-
# Invoked by any booting program (e.g., lamboot, recon) when the
# user-provided host file could not be found
# %1 = name of the host file 
The hostfile "%1" could not be found:

        Unix errno: %errno
        %perror
Things to check:

        - ensure that the file exists
          try "ls -l %1"
        - ensure that you have read permissions on the file
          try "cat %1"
-*-boot:find-hostname-*-
# Invoked by any booting program (e.g., lamgrow, lamshrink) when
# no user-provided hostname could not be found
# No parameters are passed
A hostname must be specified.
-*-boot:resolve-hostname-*-
# Invoked by any booting program (e.g., lamboot, recon) when one of
# the hosts listed in the hostfile cannot be resolved to an IP
# address.
# %1 = name of the host that we had a problem with
Could not resolve the hostname "%1" that was in the host file.

Things to check:

        - is "%1" in /etc/hosts?
          try "grep %1 /etc/hosts"
        - is "%1" resolvable by DNS (or some other naming service)?
          try "ping %1" or "dig %1" or "nslookup %1"
-*-boot:resolve-unknown-*-
# Invoked by any booting program (e.g., lamboot, recon) when some
# unknown error occurred while trying to resolve hosts in the host
# file.
# %1 = the errno
Encountered some unknown error (errno=%2) when trying to resolve
the hosts from the hostfile.  Here's a guess at the problem:

        %terror
-*-boot:duplicated-host-*-
# Invoked by any booting program (e.g., lamboot, recon) when a
# duplicate host name is discovered in a host file.
# %1 = name of the invoking program
# %2 = the duplicated host from the host file
%1 found at least one duplicated host in the list (which is not
allowed):

        %2

Please remove the duplicate entry for this host (and any other
duplicates) from the list.  

Be sure to check for multiple names that refer to the same host (i.e.,
resolve to the same IP address).

If you are trying to execute multiple copies on an SMP, you do *not*
need to list hosts more than once.  Instead, only list each host once
in the boot schema, and see the man page for mpirun(1) for the "-c"
option, which will execute multiple copies of an executable on a
single node.
-*-boot:no-localhost-*-
# Invoked when the name of the localhost was not included in the boot
# schema. 
# %1 = name of the invoking program
# %2 = name of the hostfile/boot schema
%1 found that your local host is not in the 
hostfile "%2".

The local host name *must* be in the list of hosts in the hostfile.
In other words, you must boot LAM from a node that will be part of the
universe.

        - If you simply forgot to put the local host in the boot
          schema file, add it and re-run %1
        - If you are trying to boot LAM from a node that will not be
          part of the universe, you must login to on of the nodes that
          will be part of the universe (i.e., one of the nodes in the
          hostfiles), and re-run %1

Although the local host name is usually the first in the list to avoid
I/O ambiguities, it can actually appear anywhere in the list.
-*-boot-ssi:resolve-localhost-*-
# Invoked when there are more than one hosts in the host file and one
# resolves to 127.0.0.1.  Protects users from accidently setting up an
# environment where remote lamds can not talk to the origin lamd.
# %1 = name of the invoking program
# %2 = name of offending host
%1 found that the hostname "%2" resolves to "%3".

When using LAM/MPI with more than one host, all hosts specified in the
boot schema must resolve to an address that is reachable from all
other hosts.  This is not possible with the special IP addresses
127.x.y.z -- by definition, 127.x.y.z can *only* be reached from the
local host.

In order to fix this problem:

        - Ensure that "%2" is not specified in your boot
          schema when attempting to %1 more than one host, or
        - Ensure that the hostname 

            %2

          does not resolve to 127.x.y.z.  

Note that in many recent Linux distributions, the host name of a
machine will be added to /etc/hosts for the entry 127.0.0.1.  This is
a shortcut that, while it works in many situations, is not technically
correct.  The host name of the local machine should instead be in a
separate entry with the IP address to which the name resolves.

Also note that it is perfectly acceptable to use "%3" when only
*ONE* host is being used with LAM/MPI.
-*-boot-ssi:selected-module-unavailable-*-
# Invoked when a specific boot SSI module was requested on the command
# line, but is unavailable.
# %1: Name of the module requested
The boot SSI module that was requested (%1) reports that it is 
not available to run.  If more information is required, try using the
"-d" flag.
-*-boot:server-socket-fail-*-
# This is invoked from lambootagent.c when we failed to create an
# internet server socket
# No parameters are passed
LAM failed to generate a listening internet socket.  This should not
happen -- please check your local TCP stack and setup options.

Perhaps this will help:

        Unix errno: %errno
        %perror 
-*-boot:fork-fail-*- 
# This is invoked when _lam_few fails in lambootagent.c.  It is only
# for the case where the local lamd failed to launch.
# %1 = name of the lamd executable that was attempted to be invoked
LAM failed to fork/exec a process to launch the local LAM daemon
(lamd).  LAM first launches %1 to launch the local LAM daemon, so
several things could have gone wrong:

        - "%1" itself could not be found (check your $PATH)
        - "%1" failed for some reason (consult previous error messages,
          if any)
        - Too many processes exist and Unix could not fork another
-*-boot:remote-shell-fail-*-
# This is invoked when inetexec fails in lambootagent.c.  It is only
# for the case where a remote lamd failed to launch, specifically when
# were were trying to obtain the remote shell name (i.e., before we
# tried to execute any LAM binaries)
# %1 = remote hostname/username
# %2 = local RSH attempted to be executed
# %3 = remote command attempted to be executed
# %4 = sample command to execute
LAM failed to execute a process on the remote node "%1".
LAM was not trying to invoke any LAM-specific commands yet -- we were
simply trying to determine what shell was being used on the remote
host.  

LAM tried to use the remote agent command "%2" 
to invoke "%3" on the remote node.

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

This usually indicates an authentication problem with the remote
agent, some other configuration type of error in your .cshrc or
.profile file, or you were unable to executable a command on the
remote node for some other reason.  The following is a list of items
that you should check on the remote node:

        - You have an account and can login to the remote machine
        - Incorrect permissions on your home directory (should
          probably be 0755) 
        - Incorrect permissions on your $HOME/.rhosts file (if you are
          using rsh -- they should probably be 0644) 
        - You have an entry in the remote $HOME/.rhosts file (if you
          are using rsh) for the machine and username that you are
          running from
        - Your .cshrc/.profile must not print anything out to the 
          standard error
        - Your .cshrc/.profile should set a correct TERM type
        - Your .cshrc/.profile should set the SHELL environment
          variable to your default shell

Try invoking the following command at the unix command line:

        %4

You will need to configure your local setup such that you will *not*
be prompted for a password to invoke this command on the remote node.
No output should be printed from the remote node before the output of
the command is displayed.

When you can get this command to execute successfully by hand, LAM
will probably be able to function properly.
-*-boot:remote-stderr-*-
# This is invoked when inetexec fails in lambootagent.c by getting
# something printed to the stderr from a remote shell.
# %1 = remote hostname/username
# %2 = local RSH attempted to be executed
# %3 = remote command attempted to be executed
# %4 = sample command to execute
LAM attempted to execute a process on the remote node "%1",
but received some output on the standard error.  This heuristic
assumes that any output on the standard error indicates a fatal error,
and therefore aborts.  You can disable this behavior (i.e., have LAM
ignore output on standard error) in the rsh boot module by setting the
SSI parameter boot_rsh_ignore_stderr to 1.

LAM tried to use the remote agent command "%2" 
to invoke "%3" on the remote node.

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

This can indicate an authentication error with the remote agent, or
can indicate an error in your $HOME/.cshrc, $HOME/.login, or
$HOME/.profile files.  The following is a (non-inclusive) list of items
that you should check on the remote node:

        - You have an account and can login to the remote machine
        - Incorrect permissions on your home directory (should
          probably be 0755) 
        - Incorrect permissions on your $HOME/.rhosts file (if you are
          using rsh -- they should probably be 0644) 
        - You have an entry in the remote $HOME/.rhosts file (if you
          are using rsh) for the machine and username that you are
          running from
        - Your .cshrc/.profile must not print anything out to the 
          standard error
        - Your .cshrc/.profile should set a correct TERM type
        - Your .cshrc/.profile should set the SHELL environment
          variable to your default shell

Try invoking the following command at the unix command line:

        %4

You will need to configure your local setup such that you will *not*
be prompted for a password to invoke this command on the remote node.
No output should be printed from the remote node before the output of
the command is displayed.

When you can get this command to execute successfully by hand, LAM
will probably be able to function properly.
-*-boot:no-shell-*-
# This is invoked when we fail to get a shell output from the remote node in 
# inetexec.c.  That is, the length of the output is zero.
# %1 = remote hostname/username
# %2 = local RSH attempted to be executed
# %3 = remote command attempted to be executed
# %4 = sample command to execute
LAM was trying to determine the your shell on the "%1".
However, LAM did not receive any valid output.

LAM tried to use the remote agent command "%2" 
to invoke "%3" on the remote node.

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

This is an unusual error -- it does not typically indicate a
permissions problem.  But it can sometimes indicate latent (or
"silent") errors in your $HOME/.cshrc, $HOME/.login, or $HOME/.profile
file.

Try invoking the following command at the unix command line:

        %4

You will need to configure your local setup such that you will *not*
be prompted for a password to invoke this command on the remote node.
No output should be printed from the remote node before the output of
the command is displayed.

When you can get this command to execute successfully by hand, LAM
will probably be able to function properly.
-*-boot:remote-boot-fail-*-
# This is invoked when inetexec fails in lambootagent.c.  It is only
# for the case where a remote lamd failed to launch, specifically when
# we tried to execute some LAM binary.
# %1 = remote hostname/username
# %2 = local RSH attempted to be executed
# %3 = remote shell
# %4 = sample command to execute
LAM failed to execute a LAM binary on the remote node "%1".
Since LAM was already able to determine your remote shell as "%3",
it is probable that this is not an authentication problem.

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

LAM tried to use the remote agent command "%2" 
to invoke the following command:

        %4

This can indicate several things.  You should check the following:

        - The LAM binaries are in your $PATH
        - You can run the LAM binaries
        - The $PATH variable is set properly before your 
          .cshrc/.profile exits

Try to invoke the command listed above manually at a Unix prompt.

You will need to configure your local setup such that you will *not*
be prompted for a password to invoke this command on the remote node.
No output should be printed from the remote node before the output of
the command is displayed.

When you can get this command to execute successfully by hand, LAM
will probably be able to function properly.
-*-boot:server-side-timeout-*-
# Called when lambootagent times out waiting for the newly booted
# client to call back
# No arguments are passed
The lamboot agent timed out while waiting for the newly-booted process
to call back and indicated that it had successfully booted.

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

As far as LAM could tell, the remote process started properly, but
then never called back.  Possible reasons that this may happen:

        - There are network filters between the lamboot agent host and
          the remote host such that communication on random TCP ports
          is blocked
        - Network routing from the remote host to the local host isn't
          properly configured (this is uncommon)

You can check these things by watching the output from "lamboot -d".

1. On the command line for hboot, there are two important parameters:
   one is the IP address of where the lamboot agent was invoked, the
   other is the port number that the lamboot agent is expecting the
   newly-booted process to call back on (this will be a random
   integer).

2. Manually login to the remote machine and try to telnet to the port
   indicated on the hboot command line.  For example, 
       telnet <ipnumber> <portnumber>
   If all goes well, you should get a "Connection refused" error.  If
   you get any other kind of error, it could indicate either of the
   two conditions above.  Consult with your system/network
   administrator.
-*-boot:read-clt-coord-*-
# Called when lambootagent fails reading the client coordinated over
# the socket.  This should never happen.
# No arguments are passed
The lamboot agent failed to read a message over a socket from the
newly-booted process.  This should not happen (especially since TCP is
a guaranteed protocol).  

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

You should probably check the following:

- Network connectivity: Ensure that messages can be passed reliably
  over TCP using random ports.
- Environment / PATH settings: Ensure that you are running the same
  version of LAM/MPI on all nodes.  Sometimes premature disconnects
  (and therefore this error message) may be caused if mismatched
  versions of LAM are used on different nodes.
- Node health: Ensure that the host where the newly-booted process was
  launched is healthy and still available on the network.
-*-boot:close-socket-fail-*-
# Called when lambootagent fails to close the socket from the callback
# from the newly-booted process.  This should never happen.
# No arguments are passed
The lamboot agent failed to close a socket from the newly-booted
process.  This should not happen (especially since TCP is a guaranteed
protocol).

Please check your network connectivity and ensure that messages can be
passed reliably over TCP.  Additionally, ensure that the host where
the newly-booted process was launched is healthy and still available
on the network.
-*-boot:open-client-socket-fail-*-
# Called when lambootagent fails to open a client socket to the
# newly-booted process during the fan out of the array of node
# information.
# %1 is the IP address we tried to connect to
# %2 is the port number we tried to connect to
The lamboot agent failed to open a client socket to the newly-booted
process at IP address %1, port %2.  

*** PLEASE READ THIS ENTIRE MESSAGE, FOLLOW ITS SUGGESTIONS, AND
*** CONSULT THE "BOOTING LAM" SECTION OF THE LAM/MPI FAQ
*** (http://www.lam-mpi.org/faq/) BEFORE POSTING TO THE LAM/MPI USER'S
*** MAILING LIST.

Although the newly-booted process has already communicated
successfully with the lamboot agent over other TCP sockets, this is
the first time that the lamboot agent tried to initiate a connection
to the newly-booted process.  As such, this may indicate:

        1. %1 is not the correct IP address for the machine where the
           newly-booted machine was launched
        2. There are network filters between the lamboot agent host and
           the remote host such that communication on random TCP ports
           is blocked
        3. Network routing from the the local host to the remote isn't
           properly configured (this is unlikely)

For number 1, check to ensure that %1 is the correct IP address for
that machine.  If it is not, check the host mapping on that machine
(e.g., /etc/hosts) to ensure that %1 is both reachable and is the by
the host where the lamboot agent is running, and is the correct host.

For numbers 2 and 4, try to telnet to %1, port %2.  You should get a
"connection refused" error, which will indicate that you successfully
connected to some machine at that IP address, and no process was
listening on that port.  If you get any other kind of error, check
with your system/network administrator -- it may indicate network /
routing issues between the two hosts.
-*-boot:open-client-socket-fail-*-
# Called when lambootagent fails to write down an already-established
# TCP socket.  This should never happen.
# No parameters are passed.
The lamboot agent unexpectedly failed to write data to a TCP socket
where it was communicating with a newly-booted process.  This should
not happen (especially since TCP is a guaranteed protocol).

Please check your network connectivity and ensure that messages can be
passed reliably over TCP.  Additionally, ensure that the host where
the newly-booted process was launched is healthy and still available
on the network.
-*-boot:no-schedulable-nodes-*-
# This is a warning displayed by lamboot and lamgrow if a user has a
# LAM universe with no default schedulable nodes.
WARNING: The current LAM universe has no default schedulable nodes.
For example, if you try to execute "mpirun C my_mpi_program" or
"lamexec N uptime", you will likely get "Exec format error" messages,
and nothing will run.

This is because LAM's "N" and "C" notation will only expand to
"schedulable" nodes in the LAM universe -- of which you currently
have none.  Note, however, that you can still run on explicit nodes
(e.g., "mpirun n0 n1 n2 n3 my_mpi_program").

This is a warning only.  The LAM universe is up and operating
correctly.
-*-boot:invalid-path-or-no-permission-*-
# Called by lamboot/wipe when the -prefix option is given and the prefix
# path is invalid or lamboot in that path does not have executable 
# permissions
# %1 = prefix path supplied in command line
# %2 = command name (lamboot, wipe, ...)
It seems that either you do not have a LAM installation in the
following path supplied in the prefix option

	"%1"

or you do not have executable permissions for 

	"%1/bin/%2"

-*-bhost-parse:garbage-after-hostname-*-
# Called when something after a hostname is not a key-value pair
# %1 = Line number
# %2 = Line contents
An invalid entry was found after the hostname on hostfile line %1.
This indicates either: there were two hostnames on one line, or a
key-value pair did not have valid syntax.  

Only one hostname is allowed per line, and key-value pairs must be of
the form "key=value", with no spaces.  The line will be ignored.

The offending line was:

        %2
-*-bhost-parse:hostname-must-be-first-*-
# Called when a key-value pair precedes a hostname
# %1 = Line number
# %2 = Line contents
A key-value pair was found where a hostname was expected on line %1 of
the hostfile.  

The first word on each hostfile line must be a hostname.  The line
will be ignored.

The offending line was:

        %2
-*-bhost-parse:invalid-cpu-count-*-
# Called when a CPU count is not a number, or is <=0
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, an invalid CPU count was found.  The CPU
count must be a valid positive integer.  Also, there must be no spaces
between the equals sign and the number.  The line will be ignored.

The offending line was:

        %2
-*-bhost-parse:multiple-cpu-counts-*-
# Called when more than one CPU count was found
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, multiple CPU counts were found.  Only one
CPU count is allowed per line of the hostfile.  The line will be
ignored.

The offending line was:

        %2
-*-bhost-parse:empty-username-*-
# Called when a user name is empty
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, an empty user name was found.  There must
be no spaces between the equals sign and the user name.  The line will
be ignored.

The offending line was:

        %2
-*-bhost-parse:multiple-usernames-*-
# Called when more than one username was found
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, multiple usernames were found.  Only one
user name is allowed per line of the hostfile.  The line will be
ignored.

The offending line was:

        %2
-*-bhost-parse:invalid-key-*-
# Called when an invalid key is found
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, an invalid key-value pair was
found. Probably you are having whitespaces in the key-value pair or
in unwanted places like before or after the '='. If you have multiple
values for a key, separated by whitespaces, you need to include the
complete key-value pair in double-quotes, as in "key=value1 value2"

This line will be ignored.

The offending line was:

        %2
-*-bhost-parse:imbalanced-quotes-*-
# Called when an invalid key is found
# %1 = Line number
# %2 = Line contents
In line %1 of the hostfile, you have imbalanced quotes. This line will 
be ignored.

The offending line was:

        %2
-*-recon:happiness-*-
# Invoked when recon completes successfully.
# No parameters are sent.
Woo hoo!

recon has completed successfully.  This means that you will most likely
be able to boot LAM successfully with the "lamboot" command (but this
is not a guarantee).  See the lamboot(1) manual page for more
information on the lamboot command.

If you have problems booting LAM (with lamboot) even though recon
worked successfully, enable the "-d" option to lamboot to examine each
step of lamboot and see what fails.  Most situations where recon
succeeds and lamboot fails have to do with the hboot(1) command (that
lamboot invokes on each host in the hostfile).
-*-recon:unhappiness-*-
# Invoked when recon completes unsuccessfully.
# No parameters are sent.
recon was not able to complete successfully.  There can be any number
of problems that did not allow recon to work properly.  You should use
the "-d" option to recon to get more information about each step that
recon attempts.

Any error message above may present a more detailed description of the
actual problem.

Here is general a list of prerequisites that *must* be fulfilled
before recon can work:

        - Each machine in the hostfile must be reachable and operational. 
        - You must have an account on each machine. 
        - You must be able to rsh(1) to the machine (permissions
          are typically set in the user's $HOME/.rhosts file).

        *** Sidenote: If you compiled LAM to use a remote shell program
            other than rsh (with the --with-rsh option to ./configure;
            e.g., ssh), or if you set the LAMRSH environment variable
            to an alternate remote shell program, you need to ensure
            that you can execute programs on remote nodes with no
            password.  For example:

        unix% ssh -x pinky uptime
        3:09am up 211 day(s), 23:49, 2 users, load average: 0.01, 0.08, 0.10

        - The LAM executables must be locatable on each machine, using
          the shell's search path and possibly the LAMHOME environment
          variable.  
        - The shell's start-up script must not print anything on standard
          error.  You can take advantage of the fact that rsh(1) will
          start the shell non-interactively.  The start-up script (such
          as .profile or .cshrc) can exit early in this case, before
          executing many commands relevant only to interactive sessions
          and likely to generate output.
-*-lamgrow:usage-*-
# Show the usage options of the "lamgrow" program
# No parameters are sent
Synopsis:       lamgrow [options] <hostname>

Description:    Add a node to the LAM universe

Options:
                -d           Turn on debugging / help mode
                -h           Print this message
                -n <nodeid>  Assign this ID to the new node
                -no-schedule "C" and "N" should not schedule on this node
                -ssi <key> <value>  Pass in SSI key and value
                -v           Be verbose
                -x           Run in fault tolerant mode
                <hostname>   Host to expand to

Example:        lamgrow myhost.company.com
                Add myhost.company.com to the LAM universe
-*-lamgrow:bad-node-id-*-
# Called from within the boot SSI when a bad node ID is requested for
# the new node.
# No parameters are passed
An invalid node ID was request for the new node.

New node ID's cannot be less than zero and cannot be currently in use
by a different node.

Aborting.
-*-lamgrow:host-existing-*-
# Called if a host is already part of the existing LAM universe
# %1 = hostname specified on the commands line to be lamgrown
The given host '%1' is already a part of the existing LAM
universe. You cannot add this host again to the LAM universe. 

Aborting.
-*-lamgrow:unknown-host-*-
# Called if the hostname specified in lamgrow is invalid and cannot
# be resolved
# %1 = the hostname
The host '%1' cannot be resolved. Aborting.
-*-lamgrow:localhost-universe-*-
# Called from within the boot SSI when attempting to expand a LAM
# universe that only contains a single node that has a link address of
# 127.0.0.1.
# No parameters are passed
It appears that the current LAM universe only has a single node, and
that node's address is 127.0.0.1.  lamgrow cannot grow this universe.
LAM must know the real IP address of this node -- the special
127.0.0.1 address will not work with multiple nodes.

It is suggested that you re-lamboot this universe with an IP address
of this node other than 127.0.0.1, and then invoke lamgrow again (or
simply lamboot the entire desired set of nodes).
-*-lamboot:usage-*-
# Show the usage options of the "lamboot" program
# No parameters are sent
Synopsis:   lamboot [-b] [-d] [-h] [-H] [-l] [-s] [-v] [-V] [-x] [-nn] [-np] 
                    [-c <conf file>] [-prefix </lam/install/path/>] 
                    [-ssi <key> <value>] [<bhost>]

Description:    Start up a LAM universe

Options:
        -b      Use the faster boot algorithm; will only work if shell
                on all remote nodes is same as shell on local node
        -c      Use <conf file> for start-up configuration.
                Unless you are a developer, you probably don't want
                to use this option.
        -d      Print debugging messages (implies -v)
        -h      Print this message
        -H      Don't print the header
        -l      Use local hostnname resolution (vs. centralized name lookup)
        -nn     Don't add "-n" to the remote agent command line
        -np     Do not force the execution of $HOME/.profile on remote 
		hosts
	-prefix Use the LAM installation specified in </lam/install/path>
        -ssi    Send arguments to various SSI modules.  See the
                lamboot manpage for SSI options.
        -s      Close stdout/stderr of the locally-launched LAM daemon
        -v      Be verbose
        -V      Print version and exit without booting
        -x      Run nodes in fault tolerant mode
        <bhost> Use <bhost> as the boot schema
        -session-prefix
                Set the session prefix, overriding LAM_MPI_SESSION_PREFIX.
        -session-suffix
                Set the session suffix, overriding LAM_MPI_SESSION_SUFFIX.
        -withlamprefixpath
                Override the internal installation path.  For internal
		use only, do not use unless you know what you are doing.

Session directory:
        A LAM session directory will be created on each node where the
        LAM run-time environment is started.  This directory must be
        unique to each node.  It will be created in the form:

        <prefix>/lam-<username>@<hostname>[-<suffix>]

        <prefix> will be based on the following search order:

        1. The value of the LAM_MPI_SESSION_PREFIX environment
           variable (if it exists).
        2. The value of the TMPDIR environment variable (if it
           exists).
        3. /tmp

        <suffix> will be based on the following search order (if a
        valid <suffix> is not found, it is not used):

        1. The value of the LAM_MPI_SESSION_PREFIX environment
           variable (if it exists).
        2. If running under a supported batch system, a unique job ID
           will be used.

        The suffix is specifically for the case where users need
        multiple LAM run-time environments on a single node (as is
        common in batch-queue environments).
-*-lamwipe:usage-*-
# Show the usage options of the "lamwipe" program
# No parameters are sent
Synopsis:       lamwipe [-d] [-h] [-H] [-v] [-V] [-nn] [-np] 
                        [-prefix </lam/install/path/>] [-w <#>] [<bhost>]

Description:    This command has been obsoleted by the "lamhalt" command.
                You should be using that instead.  However, "lamwipe" can
                still be used to shut down a LAM universe.

Options:
        -b      Use the faster lamwipe algorithm; will only work if shell
                on all remote nodes is same as shell on local node
        -d      Print debugging message (implies -v)
        -h      Print this message
        -H      Don't print the header
        -nn     Don't add "-n" to the remote agent command line
        -np     Do not force the execution of $HOME/.profile on remote
		hosts
	-prefix Use the LAM installation in <lam/install/path/>
        -v      Be verbose
        -V      Print version and exit without shutting down LAM
        -w <#>  Lamwipe the first <#> nodes
        <bhost> Use <bhost> as the boot schema
-*-boot:about-to-lamwipe-*-
# Invoked when lamboot/lamgrow failed and is about to do a lamwipe to
# kill all nodes that it already successfully booted.
# %1 = name of executables
%1 encountered some error (see above) during the boot process,
and will now attempt to kill all nodes that it was previously able to
boot (if any).

Please wait for LAM to finish; if you interrupt this process, you may
have LAM daemons still running on remote nodes.
-*-lamboot:lamwipe-fail-*-
# Invoked in lamboot.c when the call to _lam_few() fails when we are
# trying to tkill
# No parameters are sent.
lamboot tried to execute the "lamwipe" program on the local node to
remove any already-booted LAM nodes, but failed.  

Things to check:

        - Is "lamwipe" in your $PATH?
        - Did "lamwipe" fail for some reason (consult previous error messages,
          if any)
        - Did Unix fail to fork the "lamwipe" program due to lack of 
          resources?
-*-hboot:usage-*-
# Show the usage options of the "hboot" program
# No parameters are sent
Synopsis:       hboot [-d] [-h] [-n] [-N] [-s] [-t] [-v] [-c <schema>] 
                      [-I <inet_topo>] [-R <rtr_topo>]

Description:    Start LAM on the local node

Options:
        -c <conf>        Use <conf> as the process schema
        -b <name>        Use <name> for the unix socket names
        -d               Print debug information (implies -v)
        -h               Print this message
        -I <inet_topo>   Set $inet_topo variable
        -N               Pretend to hboot (used with recon(1))
        -R <rtr_topo>    Set $rtr_topo variable
        -s               Close stdio of processes
        -t               Kill existing session first
        -v               Be verbose
-*-hboot:cant-parse-config-*-
# Invoked from hboot.c when the boot config file is hopeless
hboot could not parse the boot configuration file.  A number
of problems can result in this error messages:

  - Is the configuration file installed properly?
  - Did you specify a file name that does not exit when
    using the -c option to lamboot?
-*-hboot:psc-parse-*-
# Invoked from hboot.c when psc_parse returns an error
# %1 = name of boot schema file that did not parse
hboot could not parse the hostfile "%1" for the following reason:

        Unix errno: %errno
        %perror
-*-hboot:nothing-to-do-*-
# Invoked from hboot.c when there is nothing to do
# %1 = name of boot schema file
hboot could not find anything to do in the hostfile "%1".

Things to check:

        - Is the file empty?
        - Does the file contain no valid hostnames?
-*-hboot:cant-find-executables-*-
# Invoked from hboot.c when we can't find an executable
# %1 = name of executable that we couldn't find
hboot could not find the executable "%1" in your path.

Things to check:

        - Is "%1" in your $PATH?
        - Does your .cshrc/.profile set your $PATH properly?

The following Unix error message may be helpful:

        Unix errno: %errno
        %perror
-*-hboot:tkill-fail-*-
# Invoked from hboot.c when tkill failed to run on the local node
# Called with no parameters
hboot was not able to run "tkill" on the local node.  

Things to check:

        - Is "tkill" in your $PATH?
        - Does your .cshrc/.profile set your $PATH properly?

The following Unix error message may be helpful:

        Unix errno: %errno
        %perror
-*-tkill:usage-*-
# Show the usage options of the "tkill" program
# No parameters are sent
Synopsis:       tkill [-d] [-h] [-N] [-v] [-debug-output <where>] [-f <killfile>] \
                      [-batchid <batchid>]
Description:    Terminate LAM on the local node.  This command is usually 
                invoked only internally in LAM.

Options:
        -batchid <name>        Use <name> for the unix socket names
        -d                     Print debug information
        -debug-output <where>  Send debug output to <where>
	-sessionsuffix <var>   Use <var> as the session suffix
        -sessionprefix <var>   Use <var> as the session prefix
        -h                     Print this message
        -N                     Pretend to tkill
        -setsid                Call setsid() before doing anything
        -v                     Be verbose

<where> is one of "stdout" or "syslog", as appropriate.  tkill will
also follow the LAM_MPI_SESSION_SUFFIX and TMPDIR environment
variables.
-*-tkill:cannot-kill-*-
# Invoked when tkill fails to kill a process that it thinks is still
# there
# %1 = PID of process that its trying to kill
tkill failed to kill the LAM daemon; I think that it is PID %1, but
"kill" and "kill -9" did not seem to kill it.

Things to check:

        - Do a "ps" and see if the process still exists
        - Use the Unix kill(1) command to kill the process
-*-compile:phome-too-long-*-
# Invoked from hcc.c/hf77.c when the LAM directory is too long
# %1 = what LAMHOME (or TROLLIUSHOME or DEFP) is
# %2 = max num of characters that it can be
# %3 = which compiler was invoked
The path name given to %3 for use with the -I and -L switches was too
long.  It can be a maximum of %2 characters long.  The pathname given was:

        %1

The pathname was given either in the $LAMHOME environment variable,
$TROLLIUSHOME environment variable, or as the prefix when LAM was
configured.
-*-compile:no-profiling-support-*-
# Invoked from hcc.c/hf77.c when -lpmpi appears on the command line,
# but LAM was not configured/compiled with profiling support.
# %1 = name of compiler invoked
%1: "-lpmpi" was included on the command line indicating use of MPI 
%1: profiling layer.  However, LAM/MPI was not compiled with support 
%1: for the MPI profiling layer; please contact your system 
%1: administrator to re-install LAM/MPI.
-*-compile:no-compiler-found-*-
# Invoked from wrapper compilers when the underlying compiler can not
# be found
# %1 = name of compiler invoked
The LAM/MPI wrapper compiler was unable to find the specified compiler
%1 in your PATH.

Note that this compiler was either specified at configure time or in
one of many possible environment variables.  Please see the man page 
for the LAM wrapper compilers for more information.
-*-hf77:no-fortran-support-*-
# Invoked when hf77 was invoked by the user, but LAM was not compiled
# with Fortran support.
Sorry, LAM/MPI was not compiled with FORTRAN support.

You will need to re-compile LAM and be sure that either ./configure
finds a FORTRAN compiler, or that you explicitly specify a FORTRAN
compiler with the --with-fc switch to ./configure.
-*-mpirun:no-init-*-
# This is invoked when mpirun received a no-init message back from one
# of the programs that it started did not seem to call MPI_Init
# %1 = Node of the process that did not invoke MPI_Init
It seems that [at least] one of the processes that was started with
mpirun did not invoke MPI_INIT before quitting (it is possible that
more than one process did not invoke MPI_INIT -- mpirun was only
notified of the first one, which was on node n%1).

mpirun can *only* be used with MPI programs (i.e., programs that
invoke MPI_INIT and MPI_FINALIZE).  You can use the "lamexec" program
to run non-MPI programs over the lambooted nodes.
-*-mpi-init:invalid-thread-level-env-*-
# Invoked from MPI_Init when LAM_MPI_THREAD_LEVEL is set to an
# invalid/unsupported value.
It seems that an invalid/unsupported thread level has been requested.
Currently supported thread-levels are:
  0 (MPI_THREAD_SINGLE)
  1 (MPI_THREAD_FUNNELLED)
  2 (MPI_THREAD_SERIALIZED)

Check the LAM_MPI_THREAD_LEVEL environment variable to ensure that it is
set properly. 
-*-mpi-init:ssi-rpi-fail-open-*-
# Invoked from MPI_Init when the RPI subsystem fails to open
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The RPI SSI subsystem failed to open during MPI_INIT.  This is a fatal
error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-rpi-fail-query-*-
# Invoked from MPI_Init when the RPI subsystem fails to query
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The RPI SSI subsystem failed to query modules successfully during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-coll-fail-open-*-
# Invoked from MPI_Init when the coll SSI subsystem fails to open
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The coll SSI subsystem failed to open during MPI_INIT.  This is a
fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-coll-fail-query-*-
# Invoked from MPI_Init when the coll SSI subsystem fails to query
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The coll SSI subsystem failed to query modules successfully during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-crmpi-fail-open-*-
# Invoked from MPI_Init when the crmpi SSI subsystem fails to open
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The crmpi SSI subsystem failed to open during MPI_INIT.  This is a
fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-crmpi-fail-query-*-
# Invoked from MPI_Init when the crmpi SSI subsystem fails to query
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The crmpi SSI subsystem failed to query modules successfully during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-crmpi-init-fail-*-
# Invoked from MPI_Init when the crmpi SSI subsystem fails to init
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The crmpi SSI subsystem failed to initialize modules successfully
during MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-select-fail-*-
# Invoked from MPI_Init when we fail to select SSI modules
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The SSI subsystem failed to select a complete set of modules during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-mismatch-*-
# Invoked from MPI_Init when we did not choose the same SSI modules as
# our peers.
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The SSI subsystem failed to select the same set of modules as its
peers during MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-rpi-init-fail-*-
# Invoked from MPI_Init when the selected RPI fails to initialize
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The selected RPI failed to initialize during MPI_INIT.  This is a
fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:ssi-rpi-crmpi-fail-*-
# Invoked from MPI_Init when the selected crmpi SSI module fails to
# initialize
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The selected CR SSI module failed to initialize during MPI_INIT.  This
is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:cid-comm-init-fail-*-
# Invoked from MPI_Init when the CID or communicator subsystems fail
* to initialize properly
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The communicator management subsystems failed to initialize during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:dtype-env-one-f77-init-fail-*-
# Invoked from MPI_Init when the datatype, environment, one-sided, or
# fortran subsystems fail to initialize properly
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The datatype, environment, environment, one-sided, or fortran
management subsystems failed to initialize during MPI_INIT.  This is a
fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:mpi-comm-self-init-fail-*-
# Invoked from MPI_Init when MPI_COMM_SELF coll SSI module fails to
# initialize properly
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The selected coll module for MPI_COMM_SELF failed to initialize during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:mpi-comm-world-init-fail-*-
# Invoked from MPI_Init when MPI_COMM_WORLD coll SSI module fails to
# initialize properly
# %1: hostname
# %2: LAM node number
# %3: PID of failed process
# %4: MPI_COMM_WORLD rank number
The selected coll module for MPI_COMM_WORLD failed to initialize during
MPI_INIT.  This is a fatal error; I must abort.

This occurred on host %1 (n%2).
The PID of failed process was %3 (MPI_COMM_WORLD rank: %4)
-*-mpi-init:rpi-mismatch-*-
# Invoked from mpirun when the MPI processes call back from MPI_INIT
# with mismatched RPI selections.
# %1 MPI_COMM_WORLD rank of first process
# %2 RPI selection of first process
# %3 MPI_COMM_WORLD rank of second process
# %4 RPI selection of second process
It seems that [at least] one of the processes that was started with
mpirun chose a different RPI than its peers.  For example, at least
the following two processes mismatched in their RPI selections:

    MPI_COMM_WORLD rank %1: %2
    MPI_COMM_WORLD rank %3: %4

All MPI processes must choose the same RPI module and version when
they start.  Check your SSI settings and/or the local environment
variables on each node.
-*-mpi-init:crmpi-mismatch-*-
# Invoked from mpirun when the MPI processes call back from MPI_INIT
# with mismatched CRMPI selections.
# %1 MPI_COMM_WORLD rank of process which has chosen a different CRMPI module
# %2 CRMPI selection of process which has chosen a different CRMPI module
# %3 CRMPI selection of mpirun 
It seems that [at least] one of the processes that was started with
mpirun chose a different CR module than mpirun.  For example, at least
the following process mismatched in its CR selection:

    MPI_COMM_WORLD rank %1: %2
    mpirun		  : %3

All MPI processes must choose the same CR module as mpirun when
they start. Check your SSI settings and/or the local environment
variables on each node.
-*-mpirun:no-finalize-*-
# Invoked when one of the processes started by mpirun exits without
# invoking MPI_FINALIZE (i.e., it doesn't detach before exiting)
# %1 pid of the failed process
# %2 node that the failed process was on
# %3 exit status of the failed process
One of the processes started by mpirun has apparently exited without
invoking MPI_FINALIZE (it had already invoked MPI_INIT).  

The program did not exit due to a signal, however.

MPI programs must invoke MPI_FINALIZE before terminating.  As such,
this is considered an error, and LAM will now kill any remaining
processes in the parallel job.

PID %1 failed on node n%2 with exit status %3.
-*-mpirun:abnormal-exit-*-
# Invoked when one of the processes started by mpirun fails
# %1 pid of the failed process
# %2 node that the failed process was on
# %3 string indicating whether the process failed or died due to signal
# %4 exit status/signal of the failed process
One of the processes started by mpirun has exited with a nonzero exit
code.  This typically indicates that the process finished in error.
If your process did not finish in error, be sure to include a "return
0" or "exit(0)" in your C code before exiting the application.

PID %1 failed on node %2 %3 %4.
-*-mpirun:no-cr-support-*-
# invoked when someone gives -crdir but LAM was not built with
# C/R abilities
You selected "-crdir" on the command line.  However, LAM/MPI is
not currently built with Checkpoint/Restart abilities.  See your
administrator if you want LAM/MPI installed with Checkpoint/
Restart support.
-*-mpirun:no-impi-support-*-
# Invoked when someone gives -client or -server to mpirun, but
# LAM was not configured/compiled with IMPI support.
You selected "-client" or "-server" on the command line, indicating
that you'd like to run an IMPI job, but LAM/MPI was not compiled with
IMPI support.  See your administrator if you want LAM/MPI installed
with IMPI support.

This flag has been ignored, and mpirun will continue.
-*-mpirun:no-impi-server-*-
# Invoked when someone gives -server option to mpirun, but LAM was not
# configured with support for the IMPI server.
You selected "-server" on the command line, indicating that you'd like
to run the IMPI server, but LAM/MPI was not compiled support for the
IMPI server.  See your administrator if you want LAM/MPI installed
with support for the IMPI server.

This flag has been ignored, and mpirun will continue.
-*-mpirun:server-without-client-*-
# Invoked when a user specifies the -server mpirun option without also
# specifying the -client option.
You have used the "-server" option to mpirun without also using the
"-client" option.  LAM currently does not support running the server
without running a client as well.  If you wish to run the server by
itself (i.e., without a LAM client), you may invoke it independently
of LAM.
-*-mpirun:cant-find-impi-server-*-
# Invoked when the user specifies -server to mpirun, but mpirun is not
# able to find the "impi-server" binary.
The "-server" option was specified to mpirun, but mpirun was not able
to locate the "impi-server" binary in your path.  Check your path for
the location of the impi-server binary.
-*-mpirun:usage-*-
# Usage message for mpirun.  No arguments.
Synopsis:       mpirun [options] <app> 
                mpirun [options] <where> <program> [<prog args>]

Description:    Start an MPI application in LAM/MPI.

Notes:
                [options]       Zero or more of the options listed below
                <app>           LAM/MPI appschema
                <where>         List of LAM nodes and/or CPUs (examples
                                below)
                <program>       Must be a LAM/MPI program that either
                                invokes MPI_INIT or has exactly one of
                                its children invoke MPI_INIT
                <prog args>     Optional list of command line arguments
                                to <program>

Options:
                -c <num>        Run <num> copies of <program> (same as -np)
                -client <rank>  <host>:<port>
                                Run IMPI job; connect to the IMPI server <host>
                                at port <port> as IMPI client number <rank>
                -D              Change current working directory of new
                                processes to the directory where the
                                executable resides
                -f              Do not open stdio descriptors
                -ger            Turn on GER mode
                -h              Print this help message
                -l              Force line-buffered output
                -lamd           Use LAM daemon (LAMD) mode (opposite of -c2c)
                -nger           Turn off GER mode
                -np <num>       Run <num> copies of <program> (same as -c)
                -nx             Don't export LAM_MPI_* environment variables
                -O              Universe is homogeneous
                -pty / -npty    Use/don't use pseudo terminals when stdout is 
                                a tty
                -s <nodeid>     Load <program> from node <nodeid>
                -sigs / -nsigs  Catch/don't catch signals in MPI application
                -ssi <n> <arg>  Set environment variable LAM_MPI_SSI_<n>=<arg>
                -toff           Enable tracing with generation initially off
                -ton, -t        Enable tracing with generation initially on
                -tv		Launch processes under TotalView Debugger
		-v              Be verbose
                -w / -nw        Wait/don't wait for application to complete
                -wd <dir>       Change current working directory of new
                                processes to <dir>
                -x <envlist>    Export environment vars in <envlist>

Nodes:          n<list>, e.g., n0-3,5
CPUS:           c<list>, e.g., c0-3,5
Extras:         h (local node), o (origin node), N (all nodes), C (all CPUs)

Examples:       mpirun n0-7 prog1
                Executes "prog1" on nodes 0 through 7.

                mpirun -lamd -x FOO=bar,DISPLAY N prog2
                Executes "prog2" on all nodes using the LAMD RPI.  
                In the environment of each process, set FOO to the value
                "bar", and set DISPLAY to the current value.

                mpirun n0 N prog3
                Run "prog3" on node 0, *and* all nodes.  This executes *2*
                copies on n0.

                mpirun C prog4 arg1 arg2
                Run "prog4" on each available CPU with command line
                arguments of "arg1" and "arg2".  If each node has a
                CPU count of 1, the "C" is equivalent to "N".  If at
                least one node has a CPU count greater than 1, LAM
                will run neighboring ranks of MPI_COMM_WORLD on that
                node.  For example, if node 0 has a CPU count of 4 and
                node 1 has a CPU count of 2, "prog4" will have
                MPI_COMM_WORLD ranks 0 through 3 on n0, and ranks 4
                and 5 on n1.

                mpirun c0 C prog5
                Similar to the "prog3" example above, this runs "prog5"
                on CPU 0 *and* on each available CPU.  This executes
                *2* copies on the node where CPU 0 is (i.e., n0).
                This is probably not a useful use of the "C" notation;
                it is only shown here for an example.

Defaults:       -c2c -w -pty -nger -nsigs
-*-mpirun:totalview-invalid-hostname-*-
# Invoked from the Totalview support code in mpirun when we somehow
# get an erroneous hostname from the lamd.
mpirun somehow got an invalid hostname for a node.  This usually
happens when node number specified is invalid i.e. not within
permissible range. This should not happen :(

Cannot continue.
-*-mpirun:totalview-invalid-process_table-*--*-
# Invoked from the Totalview support code in mpirun when we have
# uninitialized process table needed by TV in MPIR_Breakpoint()
Totalview somehow got an invalid process table when it attached to
mpirun.  This should not happen :(

Cannot continue.
-*-mpirun:totalview-exec-failed-*-
# Invoked by mpirun when the "exec" of totalview fails.
mpirun was unable to launch the totalview debugger.  Things to check:

        - Totalview is installed
        - The "totalview" executable is in your path
        - Valid licenses are available to run the Totalview debugger

The following Unix error message may be helpful:

        Unix errno: %errno
        %perror

-*-cr-ssi:specific-module-no-threads-*-
# Invoked from the CR MPI base glue when a specific CR module was
# selected by the user, but LAM was compiled without thread support.
# %1: Name of the module that was requested
The "%1" CR module was requested, but LAM/MPI was compiled without
thread support.  All LAM/MPI CR modules require thread support.
Hence, this module cannot be loaded.

Aborting.
-*-cr-ssi:selected-module-unavailable-*-
# Invoked when a specific crmpi SSI module was requested on the command
# line, but is unavailable.
# %1: Name of the module requested
The cr SSI module that was requested (%1) reports that it is 
not available to run.  
-*-cr-ssi:module-not-found-*-
# Invoked when no CRMPI module was found 
# line, but is unavailable.
# %1: Name of the module requested
The "%1" module requested in the CR kind was not found.

This typically means that you misspelled the desired module name, or used
the wrong name entirely.

-*-lamexec:usage-*-
# Usage message for lamexec.  No arguments.
Synopsis:       lamexec [options] <app>
                lamexec [options] <where> <program> [<prog args>]

Description:    Start a non-MPI job on LAM nodes.

Notes:
                [options]       Zero or more of the options listed below
                <app>           LAM/MPI appschema
                <where>         List of LAM nodes and/or CPUs (examples
                                below)
                <program>       Program to execute
                <prog args>     Optional list of command line arguments
                                to <program>

Options:
                -c <num>        Run <num> copies of <program> (same as -np)
                -D              Change current working directory of new
                                processes to the directory where the
                                executable resides
                -f              Do not open stdio descriptors
                -h              Print this help message
                -pty            Use pty if stdout is a tty
                -np <num>       Run <num> copies of <program> (same as -c)
                -npty           Do not use a pty for stdout
                -s <nodeid>     Load <program> from node <nodeid>
                -v              Be verbose
                -w / -nw        Wait / don't wait for job to complete
                -x <envlist>    Export environment vars in <envlist>

Nodes:          n<list>, e.g., n0-3,5
CPUS:           c<list>, e.g., c0-3,5
Extras:         h (local node), o (origin node), N (all nodes), C (all CPUs)

Examples:       lamexec n0-7 prog1
                Executes "prog1" on nodes 0 through 7.

                lamexec -x FOO=bar,DISPLAY N prog2
                Executes "prog2" on all nodes.  In the environment of
                each process, set FOO to the value "bar", and set
                DISPLAY to the current value.

                lamexec n0 N prog3
                Run "prog3" on node 0, *and* all nodes.  This executes *2*
                copies on n0.

                lamexec C prog4 arg1 arg2
                Run "prog4" on each available CPU with command line
                arguments of "arg1" and "arg2".  If each node has a
                CPU count of 1, the "C" is equivalent to "N".  If at
                least one node has a CPU count greater than 1, LAM
                will run multiple copies on that node.  For example,
                if node 0 has a CPU count of 4 and node 1 has a CPU
                count of 2, "prog4" will have MPI_COMM_WORLD ranks 0
                through 3 on n0, and ranks 4 and 5 on n1.

                lamexec c0 C prog5
                Similar to the "prog3" example above, this runs "prog5"
                on CPU 0 *and* on each available CPU.  This executes
                *2* copies on the node where CPU 0 is (i.e., n0).
                This is probably not a useful use of the "C" notation;
                it is only shown here for an example.

Defaults:        -w -pty
-*-lamnodes:usage-*-
# Usage message for lamnodes.  No arguments.
Synopsis:       lamnodes [options] [<where> ...]
 
Description:    Print host names of LAM nodes. If no nodes are
                specified, print host names of all nodes in the LAM.
                Uses gethostbyaddr(3) to get remote host names. If
                gethostbyaddr(3) fails, prints the IP address of the node.
 
Options:        -c        Suppress printing CPU count for each node
                -h        Print this message
                -i        Print IP addresses (instead of IP names)
                -n        Suppress printing LAM node numbers
 
Examples:       lamnodes
                        Print names of all nodes in the LAM.  This is
                        equivalent to "lamnodes N".
 
                lamnodes -n h
                        Print name of local node, with no LAM node number.
 
                lamnodes -i c0 n2 -c
                        Print IP numbers of the node where CPU 0
                        resides and of node 2.  Do not print the CPU
                        count for each node.

                lamnodes C -c -n
                        Print the IP names of the nodes where each
                        CPU resides, and suppress printing the CPU
                        count.  This will produce a valid boot schema,
                        suitable for use with lamboot.

                lamnodes N -n
                        Print the IP names of all nodes along with
                        their CPU count.  Like the above example, this
                        can be used to produce a boot schema that can
                        be used with lamboot.
-*-lamhalt:usage-*- 
# Usage message for lamhalt.  No arguments.
Synopsis: lamhalt [options]
 
Description:    Shut down an entire running LAM run time system.
                This command should be preferred over the "lamwipe" command;
                it is much faster and does not require a boot schema
                (hostfile).  Instead, it simply tells the local LAM
                daemon to shutdown and waits for acknowledgements.

Options:        -h        Print this message
                -H        Don't print the header
                -v        Be verbose
                -d        Print out lots of debugging messages

-*-hreq:timeout-*-
# Called when href() doesn't receive any ACKs in a given timeout when
# it expected to receive some.
# %1 - string list of nodes that didn't provide an ACK
LAM did not receive acknowledgements from all the LAM daemons that
should have replied.  You should check the following list of machines
for "runaway" or faulty LAM processes:

%1
-*-lamtrace:usage-*-
# Usage message for lamtrace.  No arguments
Synopsis:       lamtrace [options] [file] [nodes] [processes]
Description:    Unload trace data.

Options:        -h        Print this message
                -k        Unload, but maintain traces
                -mpi      Unload MPI traces
                -v        Operate verbosely
                -f <#>    Signal to flush, then delay <#> secs
                -R        Sweep clean traces

                file      Put trace data in file (default: def.lamtr)

Nodes:          n<list>, e.g., n0-3,5
CPUS:           c<list>, e.g., c0-3,5
Extras:         h (local node), o (origin node), N (all nodes), C (all CPUs)

Processes:      p<list> (identifiers)
                %<list> (indices)

Example:        lamtrace n3-9,11
                "Unload trace data from nodes 3 thru 9 & 11.
-*-lamtrace:nompiworld-*-
# Message that lamtrace didn't find any MPI traces
lamtrace was unable to find any MPI traces.

This may mean that there is a problem with the lam daemon or lamtrace.
More than likely, however, it means that tracing was not enabled
during any of the MPI jobs run since the last lamboot.  In order to
enable tracing, you should specify the '-t' flag to mpirun.

-*-tping:usage-*-
# Usage message for tping.  No arguments.
Synopsis:       tping [-v] [-h] [-c <count>] [-d <delay>] [-l <length>] <where>

Description:    Echo messages to Trollius nodes.  Useful for testing 
                if LAM daemons are working properly.

Options:        -h        Print this help message
                -v        Turn off verbose mode
                -c <#>    Echo <#> messages
                -l <#>    Use <#> bytes per message
                -d <#>    Delay <#> seconds between messages

Nodes:          n<list>, eg., n0-3,5,0xa,12-15
CPUs:           c<list>, eg., c0-3,5,0xa,12-15
                h (local node), o (origin node), N (all nodes), C (all CPUs)

Example:        tping n10 -c 100 -l 1024 -d 0

                Echo 100 messages of length 1024 to node 10
                without pausing between messages.

Notes:          Specifying more than one CPU on a single node is not 
                useful; LAM will translate this into a single reference 
                that node.
-*-impid:usage-*-
Synopsis:       impid client_rank num_hosts server_host server_port
or              impid client_rank num_hosts server_host:server_port

Description:    Start the LAM IMPI client daemon

Options:        client_rank  integer (0-31) specifying rank on IMPI server
                num_hosts    integer specifying local MPI_COMM_WORLD size
                server_host  IP name or number specifying location of server
                server_host  port number where server is listening

The IMPI_AUTH_KEY environment variable must be set to a valid numeric
key, or the IMPI_AUTH_NONE environment variable must exist (but this
is highly discouraged).

***********************************************************************
*** This program should probably only be run automatically from LAM ***
***********************************************************************
-*-impi-client:possible-loopback-*-
# Invoked when the impid detects 127.x.y.z from its localhostname
# %1: address in question
# %2: hostname that we got %1 from
WARNING: The LAM IMPI client has detected the address %1 from the
hostname %2.

It is likely that this is a loopback address, and will not work as
expected.  LAM will try this address anyway, but if the IMPI jobs
hangs during the setup phase, check your DNS and hostname settings.
-*-impi-client:different-private-nets-*-
# Invoked when the local IMPI host is 192.168.something or 
# 10.something, and a remove IMPI host is 10.something or
# 192.168.something, respectively (i.e., they're potentially on
# different private networks)
# %1: local IP address
# %2: local hostname
# %3: remote IP address
# %4: function name (accept or connect)
WARNING: The LAM IMPI client (hostname %2, IP address %1)
is trying to %4() to IP address %3.  

These try addresses appear to be on different private networks.  LAM
will try anyway, but it is possible that the operation will eventually
time out and fail.

If these addresses are not correct, check the DNS and hostname
settings on the node with the LAM IMPI client, as well as the nodes
that the other IMPI hosts are running on (each IMPI host reports its
own IP address; if they determine their IP address incorrectly, other
IMPI hosts may have difficulty contacting them).  Additionally, check
to ensure that both hosts are reachable (in both directions) from each
other.
-*-impi-client:local-private-net-*-
# Displayed when the IMPI host detects that it is a 192.168.x.y or
# 10.x.y.z, but one of the other hosts's IP addresses is not.
# %1: local IP address
# %2: local IP hostname
# %3: remote IP address
# %4: function (accept or connect)
WARNING: The LAM IMPI host (on %2) has determined that it is on 
a private network (%1), and that at least one other IMPI host is
on a public network (%3).

LAM will still try to connect these two hosts, but it is likely that
the connection will eventually timeout and fail.  If it does, check
the DNS and hostname settings on %2 and %3 to see if they are
reachable (in both directions) from each other.
-*-impi-client:remote-private-net-*-
# Displayed when the IMPI host detects that one or more of its host
# addresses is a 192.168.x.y or 10.x.y.z, its local address is not.
# %1: local IP address
# %2: local IP hostname
# %3: remote IP address
# %4: function (accept or connect)
WARNING: The LAM IMPI host (on %2) has determined that it is on 
a public network (%1), and that at least one other IMPI host is
on a private network (%3).

LAM will still try to connect these two hosts, but it is likely that
the connection will eventually timeout and fail.  If it does, check
the DNS and hostname settings on %2 and %3 to see if they are
reachable (in both directions) from each other.
-*-impi-client:no-auth-*-
# Message invoked when no authentication mechanism can be found by
# the IMPI client.
WARNING: No IMPI authentication method can be found!  It is highly
likely that the IMPI server will reject this connection.

The available IMPI authentication methods are:

IMPI_AUTH_KEY   - Set the "IMPI_AUTH_KEY" environment variable to a numeric
                  value.  The IMPI server must have the same value.
IMPI_AUTH_NONE  - Set the "IMPI_AUTH_NONE" environment variable.  The use
                  of this mechanism is *strongly* discouraged.

The server must share one of the available authentication methods for
IMPI authentication to succeed.
-*-impi-client:unexpected-connection-*-
# Displayed when someone made a connection during the IMPI dance comes
# from an unexpected IP address.
# %1: IP address of unexpected source
# %2: IP name of unexpected source
# %3: local hostname
WARNING: The LAM IMPI host on %3 accepted a connection from an 
unexpected IP address (%1 / %2).

The LAM IMPI host will now abort this MPI job because this could signal
an attack on your system.
-*-ALL:no-lamd-*-
# Message declaring that there is no lamd on the current node. 
# %1 = name of command that the user tried to invoke
# %2 = name of host where the command was invoked
It seems that there is no lamd running on the host %2.

This indicates that the LAM/MPI runtime environment is not operating.
The LAM/MPI runtime environment is necessary for the "%1" command.

Please run the "lamboot" command the start the LAM/MPI runtime
environment.  See the LAM/MPI documentation for how to invoke
"lamboot" across multiple machines.
-*-ALL:lamd-full-*-
# Message declaring that the lamd on the current host has filled up
# its descriptor table and cannot accept any more processes.
# %1 = name of program that the user tried to invoke
# %2 = max number of descriptors in lamd
# %3 = host name where lamd had problems
The lamd that is on the host "%3" is full.

That is, the maximum number of %2 local client processes have already
attached to that lamd.  It will refuse new connections until one or
more of the %2 current processes die.
-*-MPI:no-lamd-*-
# Message declaring that there is no lamd on the current node and some
# MPI program was attempted (i.e., not a LAM/MPI support executable)
# %1 = name of function that the user tried to invoke
# %2 = name of host where the command was invoked

It seems that there is no lamd running on the host %2.

This indicates that the LAM/MPI runtime environment is not operating.
The LAM/MPI runtime environment is necessary for MPI programs to run
(the MPI program tired to invoke the "%1" function).

Please run the "lamboot" command the start the LAM/MPI runtime
environment.  See the LAM/MPI documentation for how to invoke
"lamboot" across multiple machines.
-*-MPI:lamd-full-*-
# Message declaring that the lamd on the current host has filled up
# its descriptor table and cannot accept any more processes.
# %1 = name of function that the user tried to invoke (probably always 
#      MPI_Init)
# %2 = max number of descriptors in lamd
# %3 = host name where lamd had problems
The lamd that is on the host "%3" is full.

That is, the maximum number of %2 local client processes have already
attached to that lamd.  It will refuse new connections until one or
more of the %2 current processes die.

Hence, this MPI program will now abort, and you will get an error
message from mpirun about how some program did not complete MPI_Init.
-*-MPI:bad-mpi-init-*-
# Called from MPI_Init when lam_linit fails for some non-LAM-specific
# reason.
It seems that some error has occurred during MPI_INIT.  This will
cause your process to abort.  These kinds of errors are usually
system-related, such as running out of disk space, running out of
memory, or something more serious such as data not being passed
between processes properly.  That is, you should not be seeing this
error message; if you are, something is likely Very Wrong with your
system.  :-(

Perhaps this Unix error message will help:

        Unix errno: %errno
        %perror
-*-MPI:spawn-rpi-mismatch-*-
# Invoked from MPI_Comm_spawn* when any child MPI process calls back
# from MPI_INIT with a different RPI than the parent application.
# %1 RPI selection of parent application
# %2 child's MPI_COMM_WORLD rank
# %3 RPI selection of child process

It seems that [at least] one of the child processes that was started
by MPI_Comm_spawn* chose a different RPI than the parent MPI
application.  For example, one (of the) child process(es) that
differed from the parent is shown below:

    Parent application: %1
    Child MPI_COMM_WORLD rank %2: %3

All MPI processes must choose the same RPI module and version when
they start.  Check your SSI settings and/or the local environment
variables on each node.
-*-MPI:spawn-cr-mismatch-*-
# Invoked from MPI_Comm_spawn* when any child MPI process calls back
# from MPI_INIT with a different CR than the parent application.
# %1 CR selection of parent application
# %2 child's MPI_COMM_WORLD rank
# %3 CR selection of child process

It seems that [at least] one of the child processes that was started
by MPI_Comm_spawn* chose a different CR module than the parent 
application.  For example, one (of the) child process(es) that
differed from the parent is shown below:

    Parent application: %1
    Child MPI_COMM_WORLD rank %2: %3

All MPI processes must choose the same CR module and version when
they start.  Check your SSI settings and/or the local environment
variables on each node.
-*-sfh:open-server-socket-*-
# Called when we can't open a server socket to listen.
# %1 = rank number in MPI_COMM_WORLD
It seems that rank %1 was not able to open a TCP server socket for
some reason.  LAM is likely to abort your program shortly.  :-(

Perhaps this unix error message will help:

        Unix errno: %errno
        %perror
-*-sfh:open-client-socket-*-
# Called in the TCP RPI when we can't open a client socket to some other
# rank during the connection dance.
# %1 = rank number in MPI_COMM_WORLD
It seems that rank %1 was not able to open a TCP client socket for
some reason.  LAM is likely to abort your program shortly.  :-(

Perhaps this unix error message will help:

        Unix errno: %errno
        %perror
-*-sfh:accept-server-socket-*-
# Called in the TCP RPI when accepting on a server socket during the
# connection dance fails.
# %1 = rank number in MPI_COMM_WORLD
It seems that rank %1 was not able to accept on an already open TCP
server socket for some reason.  LAM is likely to abort your program
shortly.  :-(

Perhaps this unix error message will help:

        Unix errno: %errno
        %perror
-*-lamshrink:usage-*-
# Called in lamshrink for general usage
Synopsis:       lamshrink [-d] [-h] [-v] [-w <secs>] <nodeid>

Description:    Remove a node from a LAM universe.

Options:        
        -d           Turn on debugging / help mode
        -h           Print this message
        -v           Be verbose
        -w <secs>    Warn target node processes and pause before killing

Node:           n<id>, e.g., n5

Example:        lamshrink n3
                Remove node 3 from the LAM universe
-*-ssi:module-not-found-*-
# Called when a specific module was asked for, but was not able to be
# found at run time.
# %1: Kind of SSI
# %2: name of module requested
The %1 module named "%2" could not be found.

This typically means that you misspelled the desired module name, used
the wrong name entirely, or the module has decided that it does not
want to run in this environment.
-*-ssi-rpi:none-available-*-
# Called by the SSI RPI open function when no RPI says that it's
# available.
# No parameters are passed.
No SSI RPI modules said that they were available to run.  

This should only happen if you request an MPI thread level that is too
high (for example, none of the SSI RPI modules that are included with
LAM/MPI currently support MPI_THREAD_MULTIPLE).  If this happened and
you did not call MPI_INIT_THREAD with MPI_THREAD_MULTIPLE, something
catastrophic happened during SSI module selection such that no RPIs
were able to run.
-*-rpi-ssi:selected-module-unavailable-*-
# Invoked when a specific RPI SSI module was requested on the command
# line, but is unavailable.
# %1: Name of the module requested
The RPI SSI module that was requested (%1) reports that it is 
not available to run.  If more information is required, try using the
"-d" flag.
-*-ssi-boot:none-available-*-
# Called by the SSI boot open function when no boot module says that
# it's available.
# No parameters are passed.
No SSI boot modules said that they were available to run.  This should
not happen.
-*-ssi-boot:too-many-available-*-
# Called by the SSI boot open function when more than one boot module
# says that it's available.
# No parameters are passed.
More than one SSI boot module said that it was available to run.  This
should not happen.
-*-ssi-boot:parse-failure-*-
# Called by whoever (lamboot, lamgrow) to show that
# lam_ssi_boot_parse_options() returned a failure.
I'm confused -- the boot SSI module said that it wasn't able to parse
the command line.  Aborting in despair.
-*-ssi-boot:unable-to-init-*-
# Called by whoever (lamboot, lamgrow) to show that
# lam_ssi_boot_parse_options() returned a failure.
I'm confused -- the boot SSI module said that it wasn't able to
initialize properly.  Aborting in despair.
-*-ssi-boot:alg-not-implemented-*-
# Called by the boot SSI when a back-end algorithm has not yet been
# implemented.  The need for this error message will go away someday 
# (i.e., when threaded and tree-based booting algorithms are
# implemented).
# %1 - Name of the algorithm not yet implemented
The boot SSI does not yet implement the "%1" booting algorithm.

Please choose another.

Sorry!
-*-ssi-boot:start-unknown-rte-proc-*-
# Called by boot SSI modules when they are invoked with an unknown
# LAM RTE enum value.  This should not happen.
The SSI boot module is confused; it was called with an unknown
enum to specify which LAM RTE process to start.
-*-ssi-boot:base-startup-proto-missing-args-*-
# Called by the base TCP startup protocol in the boot SSI when 
# some command line parameters are missing.
The booted program is missing at least one of the -H, -P, or -n
command line arguments.  These arguments are required to tell the
booted program how to contact the booting agent.

Cannot continue.  Sorry.
-*-ssi-coll:none-available-*-
# Called by the SSI coll open function when no coll module says that
# it's available.
# No parameters are passed.
No SSI coll modules said that they were available to run.  This should
not happen.

-*-lamclean:usage-*-
# Show the usage options of the "lamclean" command
# No parameters are sent
Synopsis:       lamclean [options]

Description:    Clean up resources on all nodes in the LAM universe

Options:
        -h        This message
        -v        Be verbose

-*-lamcheckpoint:usage-*-
# Show the usage options of the "lamcheckpoint" command
# No parameters are sent
Synopsis:       lamcheckpoint -ssi cr [self|blcr] -pid <pid>
                              

Description:    Checkpoint a MPI Job with the given pid

Example:        lamcheckpoint -ssi cr self -pid 20000
                Checkpoint the MPI Job with pid 20000 using the cr self module

-*-lamrestart:usage-*-
# Show the usage options of the "lamrestart" command
# No parameters are sent
Synopsis: lamrestart -ssi cr blcr -ssi cr_blcr_context_file filename
       or lamrestart -ssi cr self -ssi cr_restart_args "args to mpirun"

Description:    Restart an MPI job.  If the specified cr module is blcr
                the SSI parameter to use cr_blcr_context_file, and if
                the selected cr module is self use the
                cr_self_restart_args parameter to specify the
                parameters to be passed to the new mpirun

Example:        lamrestart -ssi cr self \
                  -ssi cr_self_restart_args "-ssi rpi crtcp -np 3 myprogram"

                Restart a MPI Job, pass the parameters 
                '-ssi rpi crtcp -np 3 myprogram' to the new mpirun.

                lamrestart -ssi cr blcr \
                  -ssi cr_blcr_context_file mycontextfile

                Restart an MPI job using the BLCR checkpoint/restart
                module, using the context file 'mycontexfile' (created
                during a previous successful checkpoint).
-*-laminfo:usage-*-
# Show the usage options of the "laminfo" command
# No parameters are sent
Synopsis:       laminfo -all [-pretty|-parsable]
                laminfo [-arch] [-config] [-help|-h]
                        [-param <type> <module>] [-parsable|-pretty]
                        [-path <item>] [-version <item> <scope>]

Description:    Show information about LAM/MPI installation

Options:
        -all      Show all configuration information
        -arch     Show architecture that LAM was configured for
        -config   Show some information about LAM configuration
        -help     This message
        -param    Show SSI parameter(s) for a given SSI type (or
                  "all") and module (or "all").  Valid SSI types are:

                  all          - Show all SSI types
                  base         - Intrinsic LAM/MPI parameters
                  boot         - Boot (e.g., lamboot)
                  coll         - MPI collectives
                  cr           - Checkpoint/Restart
                  rpi          - MPI point-to-point

        -parsable Show output in an easily parsable format
        -path     Print a given configuration path.  Valid <item>
                  terms are:

                  prefix       - Prefix directory
                  bindir       - Binary directory
                  libdir       - Library directory
                  incdir       - Includes directory
                  pkglibdir    - Dynamic modules directory
                  sysconfdir   - Helpfile / configuration directory

        -pretty   Show output in a prettyprint format (default)
        -version  Print some or part of a version number of a given
                  item.  Valid <item> terms are:

                  lam          - Version of LAM/MPI
                  boot         - Version of all boot modules
                  boot:module  - Version of specific boot module
                  coll         - Version of all coll modules
                  coll:module  - Version of specific coll module
                  rpi          - Version of all rpi modules
                  rpi:module   - Version of specific rpi module
		  cr           - Version of all cr modules
		  cr:module    - Version of specific cr module

                  Valid <scope> terms are:

                  full         - Full version number
                  major        - Major version number
                  minor        - Minor version number
                  release      - Release version number
                  alpha        - Alpha version number
                  beta         - Beta version number
                  svn          - Subversion version number

If no options are given, a prettyprint set of default information is
printed.
