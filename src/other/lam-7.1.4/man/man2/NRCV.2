.TH NSEND 2 "July, 2007" "LAM 7.1.4" "LAM NETWORK LIBRARY"
.SH NAME
nsend, ntry_send, nrecv, ntry_recv  \- Send and receive LAM network
messages.
.SH C SYNOPSIS
.nf
#include <net.h>

int nsend (struct nmsg *header);
int ntry_send (struct nmsg *header);
int nrecv (struct nmsg *header);
int ntry_recv (struct nmsg *header);
.fi
.SH FORTRAN SYNOPSIS
.HP
subroutine NSND (nnode, nevent, ntype, nlength, nflags, ndata, 
ndsize, nmsg, ierror)
.HP
subroutine NRCV (nevent, ntype, nlength, nflags, ndata, ndsize, 
nmsg, ierror)
.HP
integer nevent, ntype, nlength, nflags, ndata(*), ndsize, ierror
.br
.RE
<type> nmsg(*)
.SH DESCRIPTION
The network message-passing functions add routing and packetization
to the datalink functions, dsend(2) and drecv(2).
.I nrecv()
blocks if there is no synchronizing message to receive.
.I nsend()
will block if there is no synchronizing receiving process
or forwarding process to take its message (see "Blocking").
.PP
.I ntry_send()
and
.I ntry_recv()
never cause the calling process to block.
The message is either immediately transferred, or an error is immediately
returned, indicating that the process would have blocked.
See nprobe(2) for similar functionality.
.SS Network Message Descriptor
All of the functions accept a pointer to a network message descriptor
which is an extension of the local level message descriptor
used by ksend(2) and krecv(2).
The network message descriptor is defined in <net.h>.
.PP
.RS
.ta 1i 2i
.nf
struct nmsg {
	int	nh_dl_event;
	int	nh_dl_link;
	int	nh_node;
	int	nh_event;
	int	nh_type;
	int	nh_length;
	int	nh_flags;
	int	nh_data[NHDSIZE];
	char	*nh_msg;
};
.fi
.DT
.RE
.PP
.IP nh_dl_event
unused
.sp
This field is unchanged by
.I nrecv()
but is set to the event of the synchronizing process (either the
intended receiver or a forwarding process) after calling
.IR nsend() .
See dsend(2).
.IP nh_dl_link
unused
.sp
This field is unchanged by
.I nrecv()
but is set to the output link number if the message was forwarded
to a datalink output process after calling
.IR nsend() .
See dsend(2).
.IP nh_node
This field is used by
.I nsend()
to identify the remote node running the intended receiver.
It is not used by
.IR nrecv() .
A receiving process thus cannot directly specify the source node
of a message.
Instead, receiving processes are "matched" to
messages by one or both of
.I nh_event
and
.IR nh_type .
Two special node identifiers are defined in <net.h>.
LOCAL refers to the local node and causes
.I nsend()
to bypass its routing step.
ORIGIN refers to the node from which lamboot(1) was invoked.
.sp
This field is never altered.
.IP nh_event
An event is an arbitrary positive integer used by the LAM kernel
to synchronize processes within a node.
Synchronization occurs when two events are equal.
.I nsend()
transfers the message to the destination node and
then to the highest priority process blocked on the event in the message's
.I nh_event
field and a matching type (see below).
Thus, the sender calling
.I nsend()
must set
.I nh_event
to the same value as the receiver calling
.IR nrecv() .
.sp
This field is never altered.
.IP nh_type
This field further filters messages that match on event.
A message will be transferred to a receiver only if the
.I nh_type
fields of the sender and receiver processes have at least one bit
set in an identical position.
In other words, the bitwise logical AND of the type fields specified by
the two parties must not equal zero.
A zero value matches any other value of
.IR nh_type .
.sp
This field remains unchanged after calling
.IR nsend() ,
but is set to the sender's
.I nh_type
after calling
.IR nrecv() .
.IP nh_length
This field holds the length (in bytes) of the message to be sent.
If the sender and the receiver specify different lengths,
the lesser amount will be transferred to the receiver.
Messages longer than the maximum network packet size, defined
by MAXNMSGLEN in <net.h>, will be implicitly broken down into
a series of smaller messages, which will be recombined by the receiver.
Because of this packetization, one call to
.I nsend()
can introduce many messages into the network, a possible source of confusion
during debugging.
.sp
This field remains unchanged after calling
.IR nsend() ,
but is set to the minimum of the sender's and receiver's lengths after calling
.IR nrecv() .
.IP nh_flags
This field is normally set to 0.
When the NOBUF flag (defined in <net.h>) is set in
.IR nh_flags
buffers will not be used.
Flags used to assure that the data representation is correct for the
receiving node are discussed under "Data Representation".
.sp
This field is never altered.
.IP nh_data
This field is a convenient data pouch within the network message descriptor.
Its array size is NHDSIZE words, which is defined in
<net.h> and is set to 8.
It can be used for sending short messages (in which case
.I nh_length
is set to 0)
or for appending control information to the message body.
.sp
After calling
.I nrecv()
the
.I nh_data
field is overwritten with the sender's values of the same field.
The sender's
.I nh_data
will not change.
.IP nh_msg
This field holds the address of the first byte of data to be sent
or received.
The data must be stored contiguously in memory.
.sp
This field is never altered.
.SS Data Representation
On nodes of different architectures, data may have different representations.
For example, integers may be stored with the most significant byte
first in memory (big-endian) or with the most significant byte last in
memory (little-endian).
Also, the representation of floating point numbers may conform to
the IEEE standard or may follow a vendor specific format.
All fields in the network message structure, except
the data referenced by
.IR nh_msg ,
are automatically converted if passed to a node with
different data representation.
The
.I nh_data
field is assumed to hold all integers.
.PP
The
.I nh_flags
field of the message structure can be set to the following data
representation flags.
Each flag assumes a data type, and will make the appropriate change in the
data representation of the given field.
They will have no effect if data conversion is not needed.
.TP 14
DINT4DATA
.I nh_data
holds 8 32-bit integers (default).
.TP
DFLT4DATA
.I nh_data
holds 8 single 32-bit real numbers.
.TP
DFLT8DATA
.I nh_data
holds 4 64-bit real numbers.
.TP
DRAWDATA
.I nh_data
representation will not be changed.
.TP
DINT4MSG
.I nh_msg
points to 32-bit integers.
.TP
DFLT4MSG
.I nh_msg
points to 32-bit real numbers.
.TP
DFLT8MSG
.I nh_msg
points to 64-bit real numbers.
.TP
DRAWMSG
.I nh_msg
representation will not be changed (default).
.PP
If
.I nh_data
or
.I nh_msg
contains a mixture of data types, the user will have to change the
representation using the function suites ltot(3), ttol(3), etc.
.SS Example Usage
The following example passes a message between two nodes with similar data
representations, utilizing a minimum level of synchronization.
This is intended only as a summary of a simple case.
Many variations can be constructed using the detailed information
given in the above section.
.PP
.RS
.nf
/* Sender */

#include <net.h>

struct nmsg nhead;
char *msg = "Hello, world";

nhead.nh_node = 10
nhead.nh_event = 6
nhead.nh_type = 0
nhead.nh_flags = 0
nhead.nh_length = strlen(msg) + 1;
nhead.nh_msg = msg;

nsend(&nhead);

/* Receiver */
/* Assume this code is running on node 10. */

#include <net.h>

struct nmsg nhead;
char msg[16]

nhead.nh_event = 6
nhead.nh_type = 0
nhead.nh_flags = 0
nhead.nh_length = sizeof(msg);
nhead.nh_msg = msg;

nrecv(&nhead);
.fi
.RE
.SS Blocking
A process calling
.I nrecv()
blocks until the message sent by the process calling
.I nsend()
entirely arrives.
A process calling
.I nsend()
blocks only until its message is picked up by:
.IP a)
a local receiver calling
.I nrecv()
.IP b)
a local buffer process
.IP c)
a local forwarding process such as a datalink
.LP
The only thing that is guaranteed by a successful return from
.I nsend()
is that the message has entirely left the calling process.
.PP
The loose blocking behaviour of
.I nsend()
introduces a fundamental danger of LAM message passing:  a sender
can transmit a message that may never be received due to programming
error or deadlock.
This message will never be dropped or timed out.
Some LAM process will always be stuck with it, waiting for a synchronizing
.I nrecv()
that may never happen.
If that unfortunate process is a buffer, it can
be located by the user and swept clean (see sweep(1)).
However, if the process is a link proprietor,
the link is henceforth plugged and useless.
.PP
Besides the legitimate buffer process, datalink processes can each
hold one or more messages.
NOBUF does not affect these implicit buffers.
.SH ERRORS
.PP
Errors return 
.I LAMERROR 
and set 
.I errno 
appropriately.  
The 
.I lam_perror()
and
.I lam_errorstr()
functions can be used to retrieve the error string associated with
.IR errno .
.PP
Some common 
.I errno 
values include:
.TP 16
EWOULDBLOCK
.I ntry_send()
or
.I ntry_recv()
failed because the message could not be sent or received, respectively.
A call to
.I nsend()
or
.I nrecv()
would have blocked.
.TP 16
ENOTATTACHED
The calling program is not attached to the LAM run time environment.
.SH BUGS
Multi-packet messages can inter-mingle packets if sent to the same node,
event and type.
The solution for this type of communication structure is to use
tsend(2) and trecv(2).
.SH SEE ALSO
dsend(2), nprobe(2), tsend(2)
