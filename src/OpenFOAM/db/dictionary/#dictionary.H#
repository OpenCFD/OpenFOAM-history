/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 1991-2007 OpenCFD Ltd.
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM; if not, write to the Free Software Foundation,
    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

Class
    Foam::dictionary

Description
    A dictionary is a list of keyword definitions. A keyword definition
    consists of a keyword followed by any number of values 
    (e.g. words and numbers).  Dictionary is the base class for IOdictionary
    It serves the purpose of a bootstrap dictionary for the objectRegistry data
    dictionaries, since unlike the IOdictionary class, it does not use a
    objectRegistry itself to work.

SourceFiles
    dictionary.C
    dictionaryIO.C

\*---------------------------------------------------------------------------*/

#ifndef dictionary_H
#define dictionary_H

#include "entry;;############################################################
;; Misc Setting
;;############################################################
(require 'ido)
(ido-mode t)
;;(load "fold-dwim")
(desktop-save-mode 1)
(global-font-lock-mode 1)
(setq font-lock-maximum-decoration t)
(setq font-lock-global-modes '(not text-mode))
(setq font-lock-verbose t)
(setq ring-bell-function 'ignore)
;; Make scripts executable on Save(saves having to do the chmod every time)
;;(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

(setq comint-process-echoes t)
(setq version-control 'never)
(setq dired-recursive-deletes t)
(tool-bar-mode -1)
(blink-cursor-mode -1)
(show-paren-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)
(setq suggest-key-bindings 1)
(setq inhibit-startup-message t)
(setq default-directory "e:\\gnuhome")
;;(setq debug-on-error t)
(auto-image-file-mode t)
(setq default-major-mode 'text-mode)

;; display timer
(setq display-time-24hr-format t)
(setq display-time-day-and-date t)
(display-time)

;; enhanced change buffer
(iswitchb-mode t)
;; support compressed file
;;(auto-compression-mode t)

(setq enable-recursive-minibuffers t)

(setq make-backup-file nil)
(setq bookmark-save-flag 1)
(setq colon-double-space t)
(put 'narrow-to-page 'disabled nil)


;;(autoload 'ruby-mode "ruby-mode"
;;     "Mode for editing ruby source files" t)
;;(add-hook 'ruby-mode-hook 'turn-on-font-lock)

;;add directory including the subdirectories to load-path
(if (fboundp 'normal-top-level-add-subdirs-to-load-path)
    (let* ((my-lisp-dir "~/misctools/emacs")
	   (default-directory my-lisp-dir))
      (setq load-path (cons my-lisp-dir load-path))
      (normal-top-level-add-subdirs-to-load-path)))
;;(setq load-path
;;      (append
;;       (list
;;	"~/misctools/emacs"
;;	"~/misctools/emacs/icicles"
;;	"~/misctools/emacs/init")
;;       load-path))


(autoload 'css-mode "css-mode" "Mode for editing CSS files" t)
(autoload 'nxml-mode "nxml-mode" "Mode for editing xml, xhtml files" t)
(setq auto-mode-alist
      (cons '("\\.\\(xml\\|xsl\\|xul\\|rng\\|rhtml\\|xhtml\\)\\'" . nxml-mode)
	    auto-mode-alist))
(setq auto-mode-alist
      (append '(("\\.wiki$" . muse-mode)
		("\\.css$" . css-mode)
		("\\.yml$" . conf-mode)
		("Rakefile$" . ruby-mode)
		("\\.rb$" . ruby-mode)) auto-mode-alist))


;;TABBAR MODE
(require 'tabbar)
(tabbar-mode t)
;(global-set-key (kdb "") 'tabbar-forward-group)
;(global-set-key (kdb "") 'tabbar-backward-group)
(global-set-key [(control tab)] 'tabbar-forward)
(global-set-key [(control shift tab)] 'tabbar-backward)

;;######################################################################
;; Mail Account of 126.com
;;######################################################################
(setq user-full-name "Eric Luo")
(setq user-mail-address "eric.python@126.com")

(setq send-mail-function 'smtpmail-send-it)
(setq smtpmail-default-smtp-server "smtp.126.com")
(setq smtpmail-smtp-server "smtp.126.com")
(setq smtpmail-debug-info t)
(setq smtpmail-auth-credentials
      '(("smtp.126.com" 25 "eric.python" "123659")))

;;################################################################################
;;                           Emacs SQL Setting
;;################################################################################
;; emacs
;; Make mysql not buffer sending stuff to the emacs-subprocess-pipes
;; -n unbuffered -B batch(tab separated)
;; -f force(go on after error) -i ignore spaces -q no caching -t table format 
(setq-default sql-mysql-options (quote ("-n" "-B" "-f" "-i" "-q" "-t")))
;; For Oracle
(setq-default sql-oracle-options (quote ("eric/snow327@test3_localhost")))
;(setq-default sql-password "cyberdb")

(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(blink-cursor-mode nil nil (frame))
 '(canlock-password "fb2167920638cf95c5b386459649c6e2f5ab4875")
 '(cua-mode nil)
 '(emacsw32-max-frames t)
 '(emacsw32-mode nil nil (emacsw32))
 '(emacsw32-style-frame-title t)
 '(nxml-slash-auto-complete-flag t)
 '(ps-paper-type nil nil nil "Added by setup-helper")
 '(show-paren-mode t nil (paren))
 '(transient-mark-mode nil))
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 )

;;######################################################################
;; Muse mode
;;######################################################################
(require 'psvn)

(load "ruby-config")
(load "muse-config")
(load "textile-config")
(load "misc-config")
(load "macro-config")
(load "gnus-config")
(load "nxml-config")

(eval-after-load "dired" '(require 'dired+))
(eval-after-load "dired-x" '(require 'dired+))

(require 'icicles)
(icicle-mode 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; BEGIN CHINESE SETTING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq font-encoding-alist 
     (cons '("gb2312.1980" . chinese-gbk) font-encoding-alist))
(create-fontset-from-fontset-spec
  "-*-Courier New-normal-r-*-*-16-*-*-*-c-*-fontset-chinese,
  chinese-gb2312:-outline-ËÎÌå-normal-r-normal-normal-*-*-96-96-p-*-gb2312.1980-0" t)

(setq default-frame-alist
    (append
    '((font . "fontset-chinese"))
     default-frame-alist))
(set-language-environment 'Chinese-GB)
(prefer-coding-system 'chinese-gbk-dos)
(set-keyboard-coding-system 'chinese-gbk-dos)
(set-clipboard-coding-system 'chinese-gbk-dos)
(set-terminal-coding-system 'chinese-gbk-dos)
(set-buffer-file-coding-system 'chinese-gbk-dos)
(set-selection-coding-system 'chinese-gbk-dos)
;;(modify-coding-system-alist 'process "*" 'chinese-gbk-dos)
(setq default-process-coding-system 
            '(chinese-gbk-dos . chinese-gbk-dos))
(setq-default pathname-coding-system 'chinese-gbk-dos)
;;; end of chinese input configuration
;;; END CHINESE SETTING,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   Begin Rails Setting
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;
;;(require 'mmm-mode)
;;(require 'mmm-auto)
;;(setq mmm-global-mode 'maybe)
;;(setq mmm-submode-decoration-level 2)
;;(set-face-background 'mmm-output-submode-face  "LightGrey")
;;(set-face-background 'mmm-code-submode-face    "MediumSlateBlue")
;;(set-face-background 'mmm-comment-submode-face "DarkOliveGreen")
;;(mmm-add-classes
;; '((erb-code
;;    :submode ruby-mode
;;    :match-face (("<%#" . mmm-comment-submode-face)
;;                 ("<%=" . mmm-output-submode-face)
;;                 ("<%"  . mmm-code-submode-face))
;;    :front "<%[#=]?" 
;;    :back "%>" 
;;    :insert ((?% erb-code       nil @ "<%"  @ " " _ " " @ "%>" @)
;;             (?# erb-comment    nil @ "<%#" @ " " _ " " @ "%>" @)
;;             (?= erb-expression nil @ "<%=" @ " " _ " " @ "%>" @))
;;    )))
;;(add-hook 'nxml-mode-hook
;;          (lambda ()
;;            (setq mmm-classes '(erb-code))
;;            (mmm-mode-on)))
;;;;(add-to-list 'auto-mode-alist '("\\.rhtml$" . html-mode))
;;(global-set-key [f8] 'mmm-parse-buffer)
;;

;;;;(setq transient-mark-mode nil)
;;(put 'narrow-to-region 'disabled nil).H"
#include "IDLList.H"
#include "fileName.H"
#include "ITstream.H"
#include "HashTable.H"
#include "wordList.H"
#include "className.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

// Forward declaration of friend functions and operators

class dictionary;
Istream& operator>>(Istream&, dictionary&);
Ostream& operator<<(Ostream&, const dictionary&);


/*---------------------------------------------------------------------------*\
                           Class dictionary Declaration
\*---------------------------------------------------------------------------*/

class dictionary
:
    public IDLList<entry>
{
    // Private data

        //- Dictionary name
        fileName name_;

        //- HashTable of the enries held on the DL-list for quick lookup
        HashTable<entry*> hashedEntries_;

        //- Parent dictionary
        const dictionary& parent_;

public:

        //- Read dictionary from Istream
        bool read(Istream&);

        //- Substitute the given keyword prepended by '$' with the 
        //  corresponding sub-dictionary entries
        bool substituteKeyword(const word& keyword);


public:

    //- Declare friendship with the entry class for IO
    friend class entry;


    // Declare name of the class and it's debug switch
    ClassName("dictionary");


    //- Null dictionary
    static const dictionary null;


    // Constructors

        //- Construct top-level dictionary null
        dictionary();

        //- Construct from the parent dictionary and Istream, reading entries
        //  until lastEntry or EOF
        dictionary
        (
            const dictionary& parentDict,
            Istream&
        );

        //- Construct top-level dictionary from Istream, reading entries
        //  until EOF
        dictionary(Istream&);

        //- Construct as copy given the parent dictionary
        dictionary(const dictionary& parentDict, const dictionary& dict);

        //- Construct top-level dictionary as copy
        dictionary(const dictionary& dict);

        //- Construct and return clone
        Foam::autoPtr<dictionary> clone() const;

        //- Construct top-level dictionary on freestore from Istream
        static Foam::autoPtr<dictionary> New(Istream& is);


    // Destructor

        ~dictionary();


    // Member functions

        //- Return the dictionary name
        const fileName& name() const
        {
            return name_;
        }

        //- Return the dictionary name
        fileName& name()
        {
            return name_;
        }

        //- Return the parent dictionary
        const dictionary& parent() const
        {
            return parent_;
        }

        //- Return line number of first token in dictionary
        label startLineNumber() const;

        //- Return line number of last token in dictionary
        label endLineNumber() const;


        // Search and lookup

            //- Search dictionary for given keyword
            //  If recusive search parent dictionaries
            bool found(const word& keyword, bool recusive=false) const;

            //- Find and return an entry data stream pointer if present
            //  otherwise return NULL.
            //  If recusive search parent dictionaries
            const entry* lookupEntryPtr(const word&, bool recusive=false) const;

            //- Find and return an entry data stream if present otherwise error.
            //  If recusive search parent dictionaries
            const entry& lookupEntry(const word&, bool recusive=false) const;

            //- Find and return an entry data stream
            //  If recusive search parent dictionaries
            ITstream& lookup(const word&, bool recusive=false) const;

            //- Find and return a T, if not found return the given default value
            //  If recusive search parent dictionaries
            template<class T>
            T lookupOrDefault(const word&, const T&, bool recusive=false) const;

            //- Check if entry is a sub-dictionary
            bool isDict(const word&) const;

            //- Find and return a sub-dictionary pointer if present
            //  otherwise return NULL.
            const dictionary* subDictPtr(const word&) const;

            //- Find and return a sub-dictionary
            const dictionary& subDict(const word&) const;

            //- Return the table of contents
            wordList toc() const;


        // Editing

            //- Add a new entry
            bool add(entry*, bool mergeEntry = false);

            //- Add an entry
            void add(const entry&);

            //- Add a token entry
            void add(const word& keyword, const token&);

            //- Add a word entry
            void add(const word& keyword, const word&);

            //- Add a string entry
            void add(const word& keyword, const string&);

            //- Add a label entry
            void add(const word& keyword, const label);

            //- Add a scalar entry
            void add(const word& keyword, const scalar);

            //- Add an entry constructed from a ITstream
            void add(const word& keyword, const ITstream&);

            //- Add an entry constructed from a tokenList
            void add(const word& keyword, const tokenList& tokens);

            //- Add a T entry
            template<class T>
            void add(const word& keyword, const T&);

            //- Add a dictionary entry
            void add(const word& keyword, const dictionary&);

            //- Remove an entry specified by keyword
            bool remove(const word& keyword);

            //- Change the keyword for an entry,
            //  optionally forcing overwrite of an existing entry
            bool changeKeyword
            (
                const word& oldKeyword,
                const word& newKeyword,
                bool forceOverwrite = false
            );

            //- Merge entries from the given dictionary.
            //  Also merge sub-dictionaries as required.
            bool merge(const dictionary&);

            //- Clear the dictionary
            void clear();


        // Write 

            void write(Ostream& os, bool subDict = true) const;


    // Member Operators

        //- Find and return entry
        ITstream& operator[](const word&) const;

        void operator=(const dictionary&);

        //- Include entries from the given dictionary.
        //  Warn, but do not overwrite existing entries
        void operator+=(const dictionary&);

        //- Conditionally include entries from the given dictionary.
        //  Do not overwrite existing entries.
        void operator|=(const dictionary&);

        //- Unconditionally include entries from the given dictionary.
        //  Overwrite existing entries.
        void operator<<=(const dictionary&);


    // IOstream operators

        //- Read dictionary from Istream
        friend Istream& operator>>(Istream&, dictionary&);

        //- Write dictionary to Ostream
        friend Ostream& operator<<(Ostream&, const dictionary&);
};


// Global Operators

// Combine dictionaries starting from the entries in dict one and then including
// those from dict2.
// Warn, but do not overwrite the entries from dict1.
dictionary operator+(const dictionary& dict1, const dictionary& dict2);
   
// Combine dictionaries starting from the entries in dict one and then including
// those from dict2.
// Do not overwrite the entries from dict1.
dictionary operator|(const dictionary& dict1, const dictionary& dict2);


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#ifdef NoRepository
#   include "dictionaryTemplates.C"
#endif

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#endif

// ************************************************************************* //
